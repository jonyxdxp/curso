
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Estudiante
 * 
 */
export type Estudiante = $Result.DefaultSelection<Prisma.$EstudiantePayload>
/**
 * Model Profesor
 * 
 */
export type Profesor = $Result.DefaultSelection<Prisma.$ProfesorPayload>
/**
 * Model SolicitudAcceso
 * 
 */
export type SolicitudAcceso = $Result.DefaultSelection<Prisma.$SolicitudAccesoPayload>
/**
 * Model Modulo
 * 
 */
export type Modulo = $Result.DefaultSelection<Prisma.$ModuloPayload>
/**
 * Model ProgresoEstudiante
 * 
 */
export type ProgresoEstudiante = $Result.DefaultSelection<Prisma.$ProgresoEstudiantePayload>
/**
 * Model Pago
 * 
 */
export type Pago = $Result.DefaultSelection<Prisma.$PagoPayload>
/**
 * Model ConfiguracionProfesor
 * 
 */
export type ConfiguracionProfesor = $Result.DefaultSelection<Prisma.$ConfiguracionProfesorPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  profesor: 'profesor',
  estudiante: 'estudiante'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserEstado: {
  activo: 'activo',
  inactivo: 'inactivo'
};

export type UserEstado = (typeof UserEstado)[keyof typeof UserEstado]


export const EstadoAprobacion: {
  pendiente: 'pendiente',
  aprobado: 'aprobado',
  rechazado: 'rechazado'
};

export type EstadoAprobacion = (typeof EstadoAprobacion)[keyof typeof EstadoAprobacion]


export const EstadoPago: {
  no_pagado: 'no_pagado',
  pagado: 'pagado',
  cancelado: 'cancelado'
};

export type EstadoPago = (typeof EstadoPago)[keyof typeof EstadoPago]


export const EstadoSolicitud: {
  pendiente: 'pendiente',
  aprobado: 'aprobado',
  rechazado: 'rechazado'
};

export type EstadoSolicitud = (typeof EstadoSolicitud)[keyof typeof EstadoSolicitud]


export const EstadoModulo: {
  borrador: 'borrador',
  publicado: 'publicado'
};

export type EstadoModulo = (typeof EstadoModulo)[keyof typeof EstadoModulo]


export const EstadoPagoTransaccion: {
  pendiente: 'pendiente',
  completado: 'completado',
  fallido: 'fallido',
  reembolsado: 'reembolsado'
};

export type EstadoPagoTransaccion = (typeof EstadoPagoTransaccion)[keyof typeof EstadoPagoTransaccion]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserEstado = $Enums.UserEstado

export const UserEstado: typeof $Enums.UserEstado

export type EstadoAprobacion = $Enums.EstadoAprobacion

export const EstadoAprobacion: typeof $Enums.EstadoAprobacion

export type EstadoPago = $Enums.EstadoPago

export const EstadoPago: typeof $Enums.EstadoPago

export type EstadoSolicitud = $Enums.EstadoSolicitud

export const EstadoSolicitud: typeof $Enums.EstadoSolicitud

export type EstadoModulo = $Enums.EstadoModulo

export const EstadoModulo: typeof $Enums.EstadoModulo

export type EstadoPagoTransaccion = $Enums.EstadoPagoTransaccion

export const EstadoPagoTransaccion: typeof $Enums.EstadoPagoTransaccion

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.estudiante`: Exposes CRUD operations for the **Estudiante** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estudiantes
    * const estudiantes = await prisma.estudiante.findMany()
    * ```
    */
  get estudiante(): Prisma.EstudianteDelegate<ExtArgs>;

  /**
   * `prisma.profesor`: Exposes CRUD operations for the **Profesor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profesors
    * const profesors = await prisma.profesor.findMany()
    * ```
    */
  get profesor(): Prisma.ProfesorDelegate<ExtArgs>;

  /**
   * `prisma.solicitudAcceso`: Exposes CRUD operations for the **SolicitudAcceso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SolicitudAccesos
    * const solicitudAccesos = await prisma.solicitudAcceso.findMany()
    * ```
    */
  get solicitudAcceso(): Prisma.SolicitudAccesoDelegate<ExtArgs>;

  /**
   * `prisma.modulo`: Exposes CRUD operations for the **Modulo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modulos
    * const modulos = await prisma.modulo.findMany()
    * ```
    */
  get modulo(): Prisma.ModuloDelegate<ExtArgs>;

  /**
   * `prisma.progresoEstudiante`: Exposes CRUD operations for the **ProgresoEstudiante** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgresoEstudiantes
    * const progresoEstudiantes = await prisma.progresoEstudiante.findMany()
    * ```
    */
  get progresoEstudiante(): Prisma.ProgresoEstudianteDelegate<ExtArgs>;

  /**
   * `prisma.pago`: Exposes CRUD operations for the **Pago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagos
    * const pagos = await prisma.pago.findMany()
    * ```
    */
  get pago(): Prisma.PagoDelegate<ExtArgs>;

  /**
   * `prisma.configuracionProfesor`: Exposes CRUD operations for the **ConfiguracionProfesor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfiguracionProfesors
    * const configuracionProfesors = await prisma.configuracionProfesor.findMany()
    * ```
    */
  get configuracionProfesor(): Prisma.ConfiguracionProfesorDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Estudiante: 'Estudiante',
    Profesor: 'Profesor',
    SolicitudAcceso: 'SolicitudAcceso',
    Modulo: 'Modulo',
    ProgresoEstudiante: 'ProgresoEstudiante',
    Pago: 'Pago',
    ConfiguracionProfesor: 'ConfiguracionProfesor'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "estudiante" | "profesor" | "solicitudAcceso" | "modulo" | "progresoEstudiante" | "pago" | "configuracionProfesor"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Estudiante: {
        payload: Prisma.$EstudiantePayload<ExtArgs>
        fields: Prisma.EstudianteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstudianteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstudianteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          findFirst: {
            args: Prisma.EstudianteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstudianteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          findMany: {
            args: Prisma.EstudianteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>[]
          }
          create: {
            args: Prisma.EstudianteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          createMany: {
            args: Prisma.EstudianteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EstudianteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>[]
          }
          delete: {
            args: Prisma.EstudianteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          update: {
            args: Prisma.EstudianteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          deleteMany: {
            args: Prisma.EstudianteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EstudianteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EstudianteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          aggregate: {
            args: Prisma.EstudianteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstudiante>
          }
          groupBy: {
            args: Prisma.EstudianteGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstudianteGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstudianteCountArgs<ExtArgs>
            result: $Utils.Optional<EstudianteCountAggregateOutputType> | number
          }
        }
      }
      Profesor: {
        payload: Prisma.$ProfesorPayload<ExtArgs>
        fields: Prisma.ProfesorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfesorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfesorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          findFirst: {
            args: Prisma.ProfesorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfesorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          findMany: {
            args: Prisma.ProfesorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>[]
          }
          create: {
            args: Prisma.ProfesorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          createMany: {
            args: Prisma.ProfesorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfesorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>[]
          }
          delete: {
            args: Prisma.ProfesorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          update: {
            args: Prisma.ProfesorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          deleteMany: {
            args: Prisma.ProfesorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfesorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfesorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          aggregate: {
            args: Prisma.ProfesorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfesor>
          }
          groupBy: {
            args: Prisma.ProfesorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfesorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfesorCountArgs<ExtArgs>
            result: $Utils.Optional<ProfesorCountAggregateOutputType> | number
          }
        }
      }
      SolicitudAcceso: {
        payload: Prisma.$SolicitudAccesoPayload<ExtArgs>
        fields: Prisma.SolicitudAccesoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SolicitudAccesoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolicitudAccesoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SolicitudAccesoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolicitudAccesoPayload>
          }
          findFirst: {
            args: Prisma.SolicitudAccesoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolicitudAccesoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SolicitudAccesoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolicitudAccesoPayload>
          }
          findMany: {
            args: Prisma.SolicitudAccesoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolicitudAccesoPayload>[]
          }
          create: {
            args: Prisma.SolicitudAccesoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolicitudAccesoPayload>
          }
          createMany: {
            args: Prisma.SolicitudAccesoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SolicitudAccesoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolicitudAccesoPayload>[]
          }
          delete: {
            args: Prisma.SolicitudAccesoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolicitudAccesoPayload>
          }
          update: {
            args: Prisma.SolicitudAccesoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolicitudAccesoPayload>
          }
          deleteMany: {
            args: Prisma.SolicitudAccesoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SolicitudAccesoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SolicitudAccesoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolicitudAccesoPayload>
          }
          aggregate: {
            args: Prisma.SolicitudAccesoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSolicitudAcceso>
          }
          groupBy: {
            args: Prisma.SolicitudAccesoGroupByArgs<ExtArgs>
            result: $Utils.Optional<SolicitudAccesoGroupByOutputType>[]
          }
          count: {
            args: Prisma.SolicitudAccesoCountArgs<ExtArgs>
            result: $Utils.Optional<SolicitudAccesoCountAggregateOutputType> | number
          }
        }
      }
      Modulo: {
        payload: Prisma.$ModuloPayload<ExtArgs>
        fields: Prisma.ModuloFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuloFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuloFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          findFirst: {
            args: Prisma.ModuloFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuloFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          findMany: {
            args: Prisma.ModuloFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>[]
          }
          create: {
            args: Prisma.ModuloCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          createMany: {
            args: Prisma.ModuloCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuloCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>[]
          }
          delete: {
            args: Prisma.ModuloDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          update: {
            args: Prisma.ModuloUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          deleteMany: {
            args: Prisma.ModuloDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuloUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuloUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          aggregate: {
            args: Prisma.ModuloAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModulo>
          }
          groupBy: {
            args: Prisma.ModuloGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuloGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuloCountArgs<ExtArgs>
            result: $Utils.Optional<ModuloCountAggregateOutputType> | number
          }
        }
      }
      ProgresoEstudiante: {
        payload: Prisma.$ProgresoEstudiantePayload<ExtArgs>
        fields: Prisma.ProgresoEstudianteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgresoEstudianteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresoEstudiantePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgresoEstudianteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresoEstudiantePayload>
          }
          findFirst: {
            args: Prisma.ProgresoEstudianteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresoEstudiantePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgresoEstudianteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresoEstudiantePayload>
          }
          findMany: {
            args: Prisma.ProgresoEstudianteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresoEstudiantePayload>[]
          }
          create: {
            args: Prisma.ProgresoEstudianteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresoEstudiantePayload>
          }
          createMany: {
            args: Prisma.ProgresoEstudianteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgresoEstudianteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresoEstudiantePayload>[]
          }
          delete: {
            args: Prisma.ProgresoEstudianteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresoEstudiantePayload>
          }
          update: {
            args: Prisma.ProgresoEstudianteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresoEstudiantePayload>
          }
          deleteMany: {
            args: Prisma.ProgresoEstudianteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgresoEstudianteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgresoEstudianteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresoEstudiantePayload>
          }
          aggregate: {
            args: Prisma.ProgresoEstudianteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgresoEstudiante>
          }
          groupBy: {
            args: Prisma.ProgresoEstudianteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgresoEstudianteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgresoEstudianteCountArgs<ExtArgs>
            result: $Utils.Optional<ProgresoEstudianteCountAggregateOutputType> | number
          }
        }
      }
      Pago: {
        payload: Prisma.$PagoPayload<ExtArgs>
        fields: Prisma.PagoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          findFirst: {
            args: Prisma.PagoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          findMany: {
            args: Prisma.PagoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>[]
          }
          create: {
            args: Prisma.PagoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          createMany: {
            args: Prisma.PagoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PagoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>[]
          }
          delete: {
            args: Prisma.PagoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          update: {
            args: Prisma.PagoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          deleteMany: {
            args: Prisma.PagoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PagoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          aggregate: {
            args: Prisma.PagoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePago>
          }
          groupBy: {
            args: Prisma.PagoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagoCountArgs<ExtArgs>
            result: $Utils.Optional<PagoCountAggregateOutputType> | number
          }
        }
      }
      ConfiguracionProfesor: {
        payload: Prisma.$ConfiguracionProfesorPayload<ExtArgs>
        fields: Prisma.ConfiguracionProfesorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfiguracionProfesorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionProfesorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfiguracionProfesorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionProfesorPayload>
          }
          findFirst: {
            args: Prisma.ConfiguracionProfesorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionProfesorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfiguracionProfesorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionProfesorPayload>
          }
          findMany: {
            args: Prisma.ConfiguracionProfesorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionProfesorPayload>[]
          }
          create: {
            args: Prisma.ConfiguracionProfesorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionProfesorPayload>
          }
          createMany: {
            args: Prisma.ConfiguracionProfesorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfiguracionProfesorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionProfesorPayload>[]
          }
          delete: {
            args: Prisma.ConfiguracionProfesorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionProfesorPayload>
          }
          update: {
            args: Prisma.ConfiguracionProfesorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionProfesorPayload>
          }
          deleteMany: {
            args: Prisma.ConfiguracionProfesorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfiguracionProfesorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfiguracionProfesorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionProfesorPayload>
          }
          aggregate: {
            args: Prisma.ConfiguracionProfesorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfiguracionProfesor>
          }
          groupBy: {
            args: Prisma.ConfiguracionProfesorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfiguracionProfesorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfiguracionProfesorCountArgs<ExtArgs>
            result: $Utils.Optional<ConfiguracionProfesorCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EstudianteCountOutputType
   */

  export type EstudianteCountOutputType = {
    progreso: number
    pagos: number
  }

  export type EstudianteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progreso?: boolean | EstudianteCountOutputTypeCountProgresoArgs
    pagos?: boolean | EstudianteCountOutputTypeCountPagosArgs
  }

  // Custom InputTypes
  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteCountOutputType
     */
    select?: EstudianteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeCountProgresoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgresoEstudianteWhereInput
  }

  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeCountPagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoWhereInput
  }


  /**
   * Count Type ModuloCountOutputType
   */

  export type ModuloCountOutputType = {
    progreso: number
  }

  export type ModuloCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progreso?: boolean | ModuloCountOutputTypeCountProgresoArgs
  }

  // Custom InputTypes
  /**
   * ModuloCountOutputType without action
   */
  export type ModuloCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuloCountOutputType
     */
    select?: ModuloCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuloCountOutputType without action
   */
  export type ModuloCountOutputTypeCountProgresoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgresoEstudianteWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    nombre: string | null
    avatarUrl: string | null
    rol: $Enums.UserRole | null
    estado: $Enums.UserEstado | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    nombre: string | null
    avatarUrl: string | null
    rol: $Enums.UserRole | null
    estado: $Enums.UserEstado | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    nombre: number
    avatarUrl: number
    rol: number
    estado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nombre?: true
    avatarUrl?: true
    rol?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nombre?: true
    avatarUrl?: true
    rol?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nombre?: true
    avatarUrl?: true
    rol?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string | null
    nombre: string
    avatarUrl: string | null
    rol: $Enums.UserRole
    estado: $Enums.UserEstado
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    nombre?: boolean
    avatarUrl?: boolean
    rol?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estudiante?: boolean | User$estudianteArgs<ExtArgs>
    profesor?: boolean | User$profesorArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    nombre?: boolean
    avatarUrl?: boolean
    rol?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    nombre?: boolean
    avatarUrl?: boolean
    rol?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | User$estudianteArgs<ExtArgs>
    profesor?: boolean | User$profesorArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      estudiante: Prisma.$EstudiantePayload<ExtArgs> | null
      profesor: Prisma.$ProfesorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string | null
      nombre: string
      avatarUrl: string | null
      rol: $Enums.UserRole
      estado: $Enums.UserEstado
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiante<T extends User$estudianteArgs<ExtArgs> = {}>(args?: Subset<T, User$estudianteArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    profesor<T extends User$profesorArgs<ExtArgs> = {}>(args?: Subset<T, User$profesorArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly nombre: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly rol: FieldRef<"User", 'UserRole'>
    readonly estado: FieldRef<"User", 'UserEstado'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.estudiante
   */
  export type User$estudianteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    where?: EstudianteWhereInput
  }

  /**
   * User.profesor
   */
  export type User$profesorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    where?: ProfesorWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Estudiante
   */

  export type AggregateEstudiante = {
    _count: EstudianteCountAggregateOutputType | null
    _avg: EstudianteAvgAggregateOutputType | null
    _sum: EstudianteSumAggregateOutputType | null
    _min: EstudianteMinAggregateOutputType | null
    _max: EstudianteMaxAggregateOutputType | null
  }

  export type EstudianteAvgAggregateOutputType = {
    montoPagado: Decimal | null
  }

  export type EstudianteSumAggregateOutputType = {
    montoPagado: Decimal | null
  }

  export type EstudianteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    estadoAprobacion: $Enums.EstadoAprobacion | null
    estadoPago: $Enums.EstadoPago | null
    fechaAprobacion: Date | null
    fechaPago: Date | null
    montoPagado: Decimal | null
    metodoPago: string | null
    referenciaTransaccion: string | null
    telefono: string | null
    pais: string | null
    experiencia: string | null
    interes: string | null
    fechaInscripcion: Date | null
  }

  export type EstudianteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    estadoAprobacion: $Enums.EstadoAprobacion | null
    estadoPago: $Enums.EstadoPago | null
    fechaAprobacion: Date | null
    fechaPago: Date | null
    montoPagado: Decimal | null
    metodoPago: string | null
    referenciaTransaccion: string | null
    telefono: string | null
    pais: string | null
    experiencia: string | null
    interes: string | null
    fechaInscripcion: Date | null
  }

  export type EstudianteCountAggregateOutputType = {
    id: number
    userId: number
    estadoAprobacion: number
    estadoPago: number
    fechaAprobacion: number
    fechaPago: number
    montoPagado: number
    metodoPago: number
    referenciaTransaccion: number
    telefono: number
    pais: number
    experiencia: number
    interes: number
    fechaInscripcion: number
    _all: number
  }


  export type EstudianteAvgAggregateInputType = {
    montoPagado?: true
  }

  export type EstudianteSumAggregateInputType = {
    montoPagado?: true
  }

  export type EstudianteMinAggregateInputType = {
    id?: true
    userId?: true
    estadoAprobacion?: true
    estadoPago?: true
    fechaAprobacion?: true
    fechaPago?: true
    montoPagado?: true
    metodoPago?: true
    referenciaTransaccion?: true
    telefono?: true
    pais?: true
    experiencia?: true
    interes?: true
    fechaInscripcion?: true
  }

  export type EstudianteMaxAggregateInputType = {
    id?: true
    userId?: true
    estadoAprobacion?: true
    estadoPago?: true
    fechaAprobacion?: true
    fechaPago?: true
    montoPagado?: true
    metodoPago?: true
    referenciaTransaccion?: true
    telefono?: true
    pais?: true
    experiencia?: true
    interes?: true
    fechaInscripcion?: true
  }

  export type EstudianteCountAggregateInputType = {
    id?: true
    userId?: true
    estadoAprobacion?: true
    estadoPago?: true
    fechaAprobacion?: true
    fechaPago?: true
    montoPagado?: true
    metodoPago?: true
    referenciaTransaccion?: true
    telefono?: true
    pais?: true
    experiencia?: true
    interes?: true
    fechaInscripcion?: true
    _all?: true
  }

  export type EstudianteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estudiante to aggregate.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Estudiantes
    **/
    _count?: true | EstudianteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstudianteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstudianteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstudianteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstudianteMaxAggregateInputType
  }

  export type GetEstudianteAggregateType<T extends EstudianteAggregateArgs> = {
        [P in keyof T & keyof AggregateEstudiante]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstudiante[P]>
      : GetScalarType<T[P], AggregateEstudiante[P]>
  }




  export type EstudianteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudianteWhereInput
    orderBy?: EstudianteOrderByWithAggregationInput | EstudianteOrderByWithAggregationInput[]
    by: EstudianteScalarFieldEnum[] | EstudianteScalarFieldEnum
    having?: EstudianteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstudianteCountAggregateInputType | true
    _avg?: EstudianteAvgAggregateInputType
    _sum?: EstudianteSumAggregateInputType
    _min?: EstudianteMinAggregateInputType
    _max?: EstudianteMaxAggregateInputType
  }

  export type EstudianteGroupByOutputType = {
    id: string
    userId: string
    estadoAprobacion: $Enums.EstadoAprobacion
    estadoPago: $Enums.EstadoPago
    fechaAprobacion: Date | null
    fechaPago: Date | null
    montoPagado: Decimal | null
    metodoPago: string | null
    referenciaTransaccion: string | null
    telefono: string | null
    pais: string | null
    experiencia: string | null
    interes: string | null
    fechaInscripcion: Date | null
    _count: EstudianteCountAggregateOutputType | null
    _avg: EstudianteAvgAggregateOutputType | null
    _sum: EstudianteSumAggregateOutputType | null
    _min: EstudianteMinAggregateOutputType | null
    _max: EstudianteMaxAggregateOutputType | null
  }

  type GetEstudianteGroupByPayload<T extends EstudianteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstudianteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstudianteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstudianteGroupByOutputType[P]>
            : GetScalarType<T[P], EstudianteGroupByOutputType[P]>
        }
      >
    >


  export type EstudianteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    estadoAprobacion?: boolean
    estadoPago?: boolean
    fechaAprobacion?: boolean
    fechaPago?: boolean
    montoPagado?: boolean
    metodoPago?: boolean
    referenciaTransaccion?: boolean
    telefono?: boolean
    pais?: boolean
    experiencia?: boolean
    interes?: boolean
    fechaInscripcion?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    progreso?: boolean | Estudiante$progresoArgs<ExtArgs>
    pagos?: boolean | Estudiante$pagosArgs<ExtArgs>
    solicitud?: boolean | Estudiante$solicitudArgs<ExtArgs>
    _count?: boolean | EstudianteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudiante"]>

  export type EstudianteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    estadoAprobacion?: boolean
    estadoPago?: boolean
    fechaAprobacion?: boolean
    fechaPago?: boolean
    montoPagado?: boolean
    metodoPago?: boolean
    referenciaTransaccion?: boolean
    telefono?: boolean
    pais?: boolean
    experiencia?: boolean
    interes?: boolean
    fechaInscripcion?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudiante"]>

  export type EstudianteSelectScalar = {
    id?: boolean
    userId?: boolean
    estadoAprobacion?: boolean
    estadoPago?: boolean
    fechaAprobacion?: boolean
    fechaPago?: boolean
    montoPagado?: boolean
    metodoPago?: boolean
    referenciaTransaccion?: boolean
    telefono?: boolean
    pais?: boolean
    experiencia?: boolean
    interes?: boolean
    fechaInscripcion?: boolean
  }

  export type EstudianteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    progreso?: boolean | Estudiante$progresoArgs<ExtArgs>
    pagos?: boolean | Estudiante$pagosArgs<ExtArgs>
    solicitud?: boolean | Estudiante$solicitudArgs<ExtArgs>
    _count?: boolean | EstudianteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EstudianteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EstudiantePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Estudiante"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      progreso: Prisma.$ProgresoEstudiantePayload<ExtArgs>[]
      pagos: Prisma.$PagoPayload<ExtArgs>[]
      solicitud: Prisma.$SolicitudAccesoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      estadoAprobacion: $Enums.EstadoAprobacion
      estadoPago: $Enums.EstadoPago
      fechaAprobacion: Date | null
      fechaPago: Date | null
      montoPagado: Prisma.Decimal | null
      metodoPago: string | null
      referenciaTransaccion: string | null
      telefono: string | null
      pais: string | null
      experiencia: string | null
      interes: string | null
      fechaInscripcion: Date | null
    }, ExtArgs["result"]["estudiante"]>
    composites: {}
  }

  type EstudianteGetPayload<S extends boolean | null | undefined | EstudianteDefaultArgs> = $Result.GetResult<Prisma.$EstudiantePayload, S>

  type EstudianteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EstudianteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EstudianteCountAggregateInputType | true
    }

  export interface EstudianteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Estudiante'], meta: { name: 'Estudiante' } }
    /**
     * Find zero or one Estudiante that matches the filter.
     * @param {EstudianteFindUniqueArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EstudianteFindUniqueArgs>(args: SelectSubset<T, EstudianteFindUniqueArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Estudiante that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EstudianteFindUniqueOrThrowArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EstudianteFindUniqueOrThrowArgs>(args: SelectSubset<T, EstudianteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Estudiante that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteFindFirstArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EstudianteFindFirstArgs>(args?: SelectSubset<T, EstudianteFindFirstArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Estudiante that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteFindFirstOrThrowArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EstudianteFindFirstOrThrowArgs>(args?: SelectSubset<T, EstudianteFindFirstOrThrowArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Estudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estudiantes
     * const estudiantes = await prisma.estudiante.findMany()
     * 
     * // Get first 10 Estudiantes
     * const estudiantes = await prisma.estudiante.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estudianteWithIdOnly = await prisma.estudiante.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EstudianteFindManyArgs>(args?: SelectSubset<T, EstudianteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Estudiante.
     * @param {EstudianteCreateArgs} args - Arguments to create a Estudiante.
     * @example
     * // Create one Estudiante
     * const Estudiante = await prisma.estudiante.create({
     *   data: {
     *     // ... data to create a Estudiante
     *   }
     * })
     * 
     */
    create<T extends EstudianteCreateArgs>(args: SelectSubset<T, EstudianteCreateArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Estudiantes.
     * @param {EstudianteCreateManyArgs} args - Arguments to create many Estudiantes.
     * @example
     * // Create many Estudiantes
     * const estudiante = await prisma.estudiante.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EstudianteCreateManyArgs>(args?: SelectSubset<T, EstudianteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Estudiantes and returns the data saved in the database.
     * @param {EstudianteCreateManyAndReturnArgs} args - Arguments to create many Estudiantes.
     * @example
     * // Create many Estudiantes
     * const estudiante = await prisma.estudiante.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Estudiantes and only return the `id`
     * const estudianteWithIdOnly = await prisma.estudiante.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EstudianteCreateManyAndReturnArgs>(args?: SelectSubset<T, EstudianteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Estudiante.
     * @param {EstudianteDeleteArgs} args - Arguments to delete one Estudiante.
     * @example
     * // Delete one Estudiante
     * const Estudiante = await prisma.estudiante.delete({
     *   where: {
     *     // ... filter to delete one Estudiante
     *   }
     * })
     * 
     */
    delete<T extends EstudianteDeleteArgs>(args: SelectSubset<T, EstudianteDeleteArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Estudiante.
     * @param {EstudianteUpdateArgs} args - Arguments to update one Estudiante.
     * @example
     * // Update one Estudiante
     * const estudiante = await prisma.estudiante.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EstudianteUpdateArgs>(args: SelectSubset<T, EstudianteUpdateArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Estudiantes.
     * @param {EstudianteDeleteManyArgs} args - Arguments to filter Estudiantes to delete.
     * @example
     * // Delete a few Estudiantes
     * const { count } = await prisma.estudiante.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EstudianteDeleteManyArgs>(args?: SelectSubset<T, EstudianteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estudiantes
     * const estudiante = await prisma.estudiante.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EstudianteUpdateManyArgs>(args: SelectSubset<T, EstudianteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Estudiante.
     * @param {EstudianteUpsertArgs} args - Arguments to update or create a Estudiante.
     * @example
     * // Update or create a Estudiante
     * const estudiante = await prisma.estudiante.upsert({
     *   create: {
     *     // ... data to create a Estudiante
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estudiante we want to update
     *   }
     * })
     */
    upsert<T extends EstudianteUpsertArgs>(args: SelectSubset<T, EstudianteUpsertArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteCountArgs} args - Arguments to filter Estudiantes to count.
     * @example
     * // Count the number of Estudiantes
     * const count = await prisma.estudiante.count({
     *   where: {
     *     // ... the filter for the Estudiantes we want to count
     *   }
     * })
    **/
    count<T extends EstudianteCountArgs>(
      args?: Subset<T, EstudianteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstudianteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estudiante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstudianteAggregateArgs>(args: Subset<T, EstudianteAggregateArgs>): Prisma.PrismaPromise<GetEstudianteAggregateType<T>>

    /**
     * Group by Estudiante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstudianteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstudianteGroupByArgs['orderBy'] }
        : { orderBy?: EstudianteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstudianteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstudianteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Estudiante model
   */
  readonly fields: EstudianteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Estudiante.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstudianteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    progreso<T extends Estudiante$progresoArgs<ExtArgs> = {}>(args?: Subset<T, Estudiante$progresoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgresoEstudiantePayload<ExtArgs>, T, "findMany"> | Null>
    pagos<T extends Estudiante$pagosArgs<ExtArgs> = {}>(args?: Subset<T, Estudiante$pagosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findMany"> | Null>
    solicitud<T extends Estudiante$solicitudArgs<ExtArgs> = {}>(args?: Subset<T, Estudiante$solicitudArgs<ExtArgs>>): Prisma__SolicitudAccesoClient<$Result.GetResult<Prisma.$SolicitudAccesoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Estudiante model
   */ 
  interface EstudianteFieldRefs {
    readonly id: FieldRef<"Estudiante", 'String'>
    readonly userId: FieldRef<"Estudiante", 'String'>
    readonly estadoAprobacion: FieldRef<"Estudiante", 'EstadoAprobacion'>
    readonly estadoPago: FieldRef<"Estudiante", 'EstadoPago'>
    readonly fechaAprobacion: FieldRef<"Estudiante", 'DateTime'>
    readonly fechaPago: FieldRef<"Estudiante", 'DateTime'>
    readonly montoPagado: FieldRef<"Estudiante", 'Decimal'>
    readonly metodoPago: FieldRef<"Estudiante", 'String'>
    readonly referenciaTransaccion: FieldRef<"Estudiante", 'String'>
    readonly telefono: FieldRef<"Estudiante", 'String'>
    readonly pais: FieldRef<"Estudiante", 'String'>
    readonly experiencia: FieldRef<"Estudiante", 'String'>
    readonly interes: FieldRef<"Estudiante", 'String'>
    readonly fechaInscripcion: FieldRef<"Estudiante", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Estudiante findUnique
   */
  export type EstudianteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante findUniqueOrThrow
   */
  export type EstudianteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante findFirst
   */
  export type EstudianteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estudiantes.
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estudiantes.
     */
    distinct?: EstudianteScalarFieldEnum | EstudianteScalarFieldEnum[]
  }

  /**
   * Estudiante findFirstOrThrow
   */
  export type EstudianteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estudiantes.
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estudiantes.
     */
    distinct?: EstudianteScalarFieldEnum | EstudianteScalarFieldEnum[]
  }

  /**
   * Estudiante findMany
   */
  export type EstudianteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiantes to fetch.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Estudiantes.
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    distinct?: EstudianteScalarFieldEnum | EstudianteScalarFieldEnum[]
  }

  /**
   * Estudiante create
   */
  export type EstudianteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * The data needed to create a Estudiante.
     */
    data: XOR<EstudianteCreateInput, EstudianteUncheckedCreateInput>
  }

  /**
   * Estudiante createMany
   */
  export type EstudianteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Estudiantes.
     */
    data: EstudianteCreateManyInput | EstudianteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Estudiante createManyAndReturn
   */
  export type EstudianteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Estudiantes.
     */
    data: EstudianteCreateManyInput | EstudianteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Estudiante update
   */
  export type EstudianteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * The data needed to update a Estudiante.
     */
    data: XOR<EstudianteUpdateInput, EstudianteUncheckedUpdateInput>
    /**
     * Choose, which Estudiante to update.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante updateMany
   */
  export type EstudianteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Estudiantes.
     */
    data: XOR<EstudianteUpdateManyMutationInput, EstudianteUncheckedUpdateManyInput>
    /**
     * Filter which Estudiantes to update
     */
    where?: EstudianteWhereInput
  }

  /**
   * Estudiante upsert
   */
  export type EstudianteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * The filter to search for the Estudiante to update in case it exists.
     */
    where: EstudianteWhereUniqueInput
    /**
     * In case the Estudiante found by the `where` argument doesn't exist, create a new Estudiante with this data.
     */
    create: XOR<EstudianteCreateInput, EstudianteUncheckedCreateInput>
    /**
     * In case the Estudiante was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstudianteUpdateInput, EstudianteUncheckedUpdateInput>
  }

  /**
   * Estudiante delete
   */
  export type EstudianteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter which Estudiante to delete.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante deleteMany
   */
  export type EstudianteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estudiantes to delete
     */
    where?: EstudianteWhereInput
  }

  /**
   * Estudiante.progreso
   */
  export type Estudiante$progresoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresoEstudiante
     */
    select?: ProgresoEstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresoEstudianteInclude<ExtArgs> | null
    where?: ProgresoEstudianteWhereInput
    orderBy?: ProgresoEstudianteOrderByWithRelationInput | ProgresoEstudianteOrderByWithRelationInput[]
    cursor?: ProgresoEstudianteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgresoEstudianteScalarFieldEnum | ProgresoEstudianteScalarFieldEnum[]
  }

  /**
   * Estudiante.pagos
   */
  export type Estudiante$pagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    where?: PagoWhereInput
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    cursor?: PagoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Estudiante.solicitud
   */
  export type Estudiante$solicitudArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitudAcceso
     */
    select?: SolicitudAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolicitudAccesoInclude<ExtArgs> | null
    where?: SolicitudAccesoWhereInput
  }

  /**
   * Estudiante without action
   */
  export type EstudianteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
  }


  /**
   * Model Profesor
   */

  export type AggregateProfesor = {
    _count: ProfesorCountAggregateOutputType | null
    _min: ProfesorMinAggregateOutputType | null
    _max: ProfesorMaxAggregateOutputType | null
  }

  export type ProfesorMinAggregateOutputType = {
    id: string | null
    userId: string | null
    ultimoLogin: Date | null
  }

  export type ProfesorMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    ultimoLogin: Date | null
  }

  export type ProfesorCountAggregateOutputType = {
    id: number
    userId: number
    permisos: number
    ultimoLogin: number
    _all: number
  }


  export type ProfesorMinAggregateInputType = {
    id?: true
    userId?: true
    ultimoLogin?: true
  }

  export type ProfesorMaxAggregateInputType = {
    id?: true
    userId?: true
    ultimoLogin?: true
  }

  export type ProfesorCountAggregateInputType = {
    id?: true
    userId?: true
    permisos?: true
    ultimoLogin?: true
    _all?: true
  }

  export type ProfesorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profesor to aggregate.
     */
    where?: ProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesors to fetch.
     */
    orderBy?: ProfesorOrderByWithRelationInput | ProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profesors
    **/
    _count?: true | ProfesorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfesorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfesorMaxAggregateInputType
  }

  export type GetProfesorAggregateType<T extends ProfesorAggregateArgs> = {
        [P in keyof T & keyof AggregateProfesor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfesor[P]>
      : GetScalarType<T[P], AggregateProfesor[P]>
  }




  export type ProfesorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfesorWhereInput
    orderBy?: ProfesorOrderByWithAggregationInput | ProfesorOrderByWithAggregationInput[]
    by: ProfesorScalarFieldEnum[] | ProfesorScalarFieldEnum
    having?: ProfesorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfesorCountAggregateInputType | true
    _min?: ProfesorMinAggregateInputType
    _max?: ProfesorMaxAggregateInputType
  }

  export type ProfesorGroupByOutputType = {
    id: string
    userId: string
    permisos: string[]
    ultimoLogin: Date | null
    _count: ProfesorCountAggregateOutputType | null
    _min: ProfesorMinAggregateOutputType | null
    _max: ProfesorMaxAggregateOutputType | null
  }

  type GetProfesorGroupByPayload<T extends ProfesorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfesorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfesorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfesorGroupByOutputType[P]>
            : GetScalarType<T[P], ProfesorGroupByOutputType[P]>
        }
      >
    >


  export type ProfesorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permisos?: boolean
    ultimoLogin?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    configuracion?: boolean | Profesor$configuracionArgs<ExtArgs>
  }, ExtArgs["result"]["profesor"]>

  export type ProfesorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permisos?: boolean
    ultimoLogin?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profesor"]>

  export type ProfesorSelectScalar = {
    id?: boolean
    userId?: boolean
    permisos?: boolean
    ultimoLogin?: boolean
  }

  export type ProfesorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    configuracion?: boolean | Profesor$configuracionArgs<ExtArgs>
  }
  export type ProfesorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfesorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profesor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      configuracion: Prisma.$ConfiguracionProfesorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      permisos: string[]
      ultimoLogin: Date | null
    }, ExtArgs["result"]["profesor"]>
    composites: {}
  }

  type ProfesorGetPayload<S extends boolean | null | undefined | ProfesorDefaultArgs> = $Result.GetResult<Prisma.$ProfesorPayload, S>

  type ProfesorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfesorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfesorCountAggregateInputType | true
    }

  export interface ProfesorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profesor'], meta: { name: 'Profesor' } }
    /**
     * Find zero or one Profesor that matches the filter.
     * @param {ProfesorFindUniqueArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfesorFindUniqueArgs>(args: SelectSubset<T, ProfesorFindUniqueArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profesor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfesorFindUniqueOrThrowArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfesorFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfesorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profesor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorFindFirstArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfesorFindFirstArgs>(args?: SelectSubset<T, ProfesorFindFirstArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profesor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorFindFirstOrThrowArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfesorFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfesorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profesors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profesors
     * const profesors = await prisma.profesor.findMany()
     * 
     * // Get first 10 Profesors
     * const profesors = await prisma.profesor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profesorWithIdOnly = await prisma.profesor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfesorFindManyArgs>(args?: SelectSubset<T, ProfesorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profesor.
     * @param {ProfesorCreateArgs} args - Arguments to create a Profesor.
     * @example
     * // Create one Profesor
     * const Profesor = await prisma.profesor.create({
     *   data: {
     *     // ... data to create a Profesor
     *   }
     * })
     * 
     */
    create<T extends ProfesorCreateArgs>(args: SelectSubset<T, ProfesorCreateArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profesors.
     * @param {ProfesorCreateManyArgs} args - Arguments to create many Profesors.
     * @example
     * // Create many Profesors
     * const profesor = await prisma.profesor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfesorCreateManyArgs>(args?: SelectSubset<T, ProfesorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profesors and returns the data saved in the database.
     * @param {ProfesorCreateManyAndReturnArgs} args - Arguments to create many Profesors.
     * @example
     * // Create many Profesors
     * const profesor = await prisma.profesor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profesors and only return the `id`
     * const profesorWithIdOnly = await prisma.profesor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfesorCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfesorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profesor.
     * @param {ProfesorDeleteArgs} args - Arguments to delete one Profesor.
     * @example
     * // Delete one Profesor
     * const Profesor = await prisma.profesor.delete({
     *   where: {
     *     // ... filter to delete one Profesor
     *   }
     * })
     * 
     */
    delete<T extends ProfesorDeleteArgs>(args: SelectSubset<T, ProfesorDeleteArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profesor.
     * @param {ProfesorUpdateArgs} args - Arguments to update one Profesor.
     * @example
     * // Update one Profesor
     * const profesor = await prisma.profesor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfesorUpdateArgs>(args: SelectSubset<T, ProfesorUpdateArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profesors.
     * @param {ProfesorDeleteManyArgs} args - Arguments to filter Profesors to delete.
     * @example
     * // Delete a few Profesors
     * const { count } = await prisma.profesor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfesorDeleteManyArgs>(args?: SelectSubset<T, ProfesorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profesors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profesors
     * const profesor = await prisma.profesor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfesorUpdateManyArgs>(args: SelectSubset<T, ProfesorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profesor.
     * @param {ProfesorUpsertArgs} args - Arguments to update or create a Profesor.
     * @example
     * // Update or create a Profesor
     * const profesor = await prisma.profesor.upsert({
     *   create: {
     *     // ... data to create a Profesor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profesor we want to update
     *   }
     * })
     */
    upsert<T extends ProfesorUpsertArgs>(args: SelectSubset<T, ProfesorUpsertArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profesors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorCountArgs} args - Arguments to filter Profesors to count.
     * @example
     * // Count the number of Profesors
     * const count = await prisma.profesor.count({
     *   where: {
     *     // ... the filter for the Profesors we want to count
     *   }
     * })
    **/
    count<T extends ProfesorCountArgs>(
      args?: Subset<T, ProfesorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfesorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profesor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfesorAggregateArgs>(args: Subset<T, ProfesorAggregateArgs>): Prisma.PrismaPromise<GetProfesorAggregateType<T>>

    /**
     * Group by Profesor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfesorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfesorGroupByArgs['orderBy'] }
        : { orderBy?: ProfesorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfesorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfesorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profesor model
   */
  readonly fields: ProfesorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profesor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfesorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    configuracion<T extends Profesor$configuracionArgs<ExtArgs> = {}>(args?: Subset<T, Profesor$configuracionArgs<ExtArgs>>): Prisma__ConfiguracionProfesorClient<$Result.GetResult<Prisma.$ConfiguracionProfesorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profesor model
   */ 
  interface ProfesorFieldRefs {
    readonly id: FieldRef<"Profesor", 'String'>
    readonly userId: FieldRef<"Profesor", 'String'>
    readonly permisos: FieldRef<"Profesor", 'String[]'>
    readonly ultimoLogin: FieldRef<"Profesor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profesor findUnique
   */
  export type ProfesorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesor to fetch.
     */
    where: ProfesorWhereUniqueInput
  }

  /**
   * Profesor findUniqueOrThrow
   */
  export type ProfesorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesor to fetch.
     */
    where: ProfesorWhereUniqueInput
  }

  /**
   * Profesor findFirst
   */
  export type ProfesorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesor to fetch.
     */
    where?: ProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesors to fetch.
     */
    orderBy?: ProfesorOrderByWithRelationInput | ProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profesors.
     */
    cursor?: ProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profesors.
     */
    distinct?: ProfesorScalarFieldEnum | ProfesorScalarFieldEnum[]
  }

  /**
   * Profesor findFirstOrThrow
   */
  export type ProfesorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesor to fetch.
     */
    where?: ProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesors to fetch.
     */
    orderBy?: ProfesorOrderByWithRelationInput | ProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profesors.
     */
    cursor?: ProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profesors.
     */
    distinct?: ProfesorScalarFieldEnum | ProfesorScalarFieldEnum[]
  }

  /**
   * Profesor findMany
   */
  export type ProfesorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesors to fetch.
     */
    where?: ProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesors to fetch.
     */
    orderBy?: ProfesorOrderByWithRelationInput | ProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profesors.
     */
    cursor?: ProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesors.
     */
    skip?: number
    distinct?: ProfesorScalarFieldEnum | ProfesorScalarFieldEnum[]
  }

  /**
   * Profesor create
   */
  export type ProfesorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * The data needed to create a Profesor.
     */
    data: XOR<ProfesorCreateInput, ProfesorUncheckedCreateInput>
  }

  /**
   * Profesor createMany
   */
  export type ProfesorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profesors.
     */
    data: ProfesorCreateManyInput | ProfesorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profesor createManyAndReturn
   */
  export type ProfesorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profesors.
     */
    data: ProfesorCreateManyInput | ProfesorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profesor update
   */
  export type ProfesorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * The data needed to update a Profesor.
     */
    data: XOR<ProfesorUpdateInput, ProfesorUncheckedUpdateInput>
    /**
     * Choose, which Profesor to update.
     */
    where: ProfesorWhereUniqueInput
  }

  /**
   * Profesor updateMany
   */
  export type ProfesorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profesors.
     */
    data: XOR<ProfesorUpdateManyMutationInput, ProfesorUncheckedUpdateManyInput>
    /**
     * Filter which Profesors to update
     */
    where?: ProfesorWhereInput
  }

  /**
   * Profesor upsert
   */
  export type ProfesorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * The filter to search for the Profesor to update in case it exists.
     */
    where: ProfesorWhereUniqueInput
    /**
     * In case the Profesor found by the `where` argument doesn't exist, create a new Profesor with this data.
     */
    create: XOR<ProfesorCreateInput, ProfesorUncheckedCreateInput>
    /**
     * In case the Profesor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfesorUpdateInput, ProfesorUncheckedUpdateInput>
  }

  /**
   * Profesor delete
   */
  export type ProfesorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter which Profesor to delete.
     */
    where: ProfesorWhereUniqueInput
  }

  /**
   * Profesor deleteMany
   */
  export type ProfesorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profesors to delete
     */
    where?: ProfesorWhereInput
  }

  /**
   * Profesor.configuracion
   */
  export type Profesor$configuracionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionProfesor
     */
    select?: ConfiguracionProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionProfesorInclude<ExtArgs> | null
    where?: ConfiguracionProfesorWhereInput
  }

  /**
   * Profesor without action
   */
  export type ProfesorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
  }


  /**
   * Model SolicitudAcceso
   */

  export type AggregateSolicitudAcceso = {
    _count: SolicitudAccesoCountAggregateOutputType | null
    _min: SolicitudAccesoMinAggregateOutputType | null
    _max: SolicitudAccesoMaxAggregateOutputType | null
  }

  export type SolicitudAccesoMinAggregateOutputType = {
    id: string | null
    estudianteId: string | null
    nombre: string | null
    email: string | null
    telefono: string | null
    pais: string | null
    experiencia: string | null
    interes: string | null
    estado: $Enums.EstadoSolicitud | null
    fechaSolicitud: Date | null
    fechaRevision: Date | null
    motivoRechazo: string | null
    createdAt: Date | null
  }

  export type SolicitudAccesoMaxAggregateOutputType = {
    id: string | null
    estudianteId: string | null
    nombre: string | null
    email: string | null
    telefono: string | null
    pais: string | null
    experiencia: string | null
    interes: string | null
    estado: $Enums.EstadoSolicitud | null
    fechaSolicitud: Date | null
    fechaRevision: Date | null
    motivoRechazo: string | null
    createdAt: Date | null
  }

  export type SolicitudAccesoCountAggregateOutputType = {
    id: number
    estudianteId: number
    nombre: number
    email: number
    telefono: number
    pais: number
    experiencia: number
    interes: number
    estado: number
    fechaSolicitud: number
    fechaRevision: number
    motivoRechazo: number
    createdAt: number
    _all: number
  }


  export type SolicitudAccesoMinAggregateInputType = {
    id?: true
    estudianteId?: true
    nombre?: true
    email?: true
    telefono?: true
    pais?: true
    experiencia?: true
    interes?: true
    estado?: true
    fechaSolicitud?: true
    fechaRevision?: true
    motivoRechazo?: true
    createdAt?: true
  }

  export type SolicitudAccesoMaxAggregateInputType = {
    id?: true
    estudianteId?: true
    nombre?: true
    email?: true
    telefono?: true
    pais?: true
    experiencia?: true
    interes?: true
    estado?: true
    fechaSolicitud?: true
    fechaRevision?: true
    motivoRechazo?: true
    createdAt?: true
  }

  export type SolicitudAccesoCountAggregateInputType = {
    id?: true
    estudianteId?: true
    nombre?: true
    email?: true
    telefono?: true
    pais?: true
    experiencia?: true
    interes?: true
    estado?: true
    fechaSolicitud?: true
    fechaRevision?: true
    motivoRechazo?: true
    createdAt?: true
    _all?: true
  }

  export type SolicitudAccesoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SolicitudAcceso to aggregate.
     */
    where?: SolicitudAccesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SolicitudAccesos to fetch.
     */
    orderBy?: SolicitudAccesoOrderByWithRelationInput | SolicitudAccesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SolicitudAccesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SolicitudAccesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SolicitudAccesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SolicitudAccesos
    **/
    _count?: true | SolicitudAccesoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SolicitudAccesoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SolicitudAccesoMaxAggregateInputType
  }

  export type GetSolicitudAccesoAggregateType<T extends SolicitudAccesoAggregateArgs> = {
        [P in keyof T & keyof AggregateSolicitudAcceso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSolicitudAcceso[P]>
      : GetScalarType<T[P], AggregateSolicitudAcceso[P]>
  }




  export type SolicitudAccesoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SolicitudAccesoWhereInput
    orderBy?: SolicitudAccesoOrderByWithAggregationInput | SolicitudAccesoOrderByWithAggregationInput[]
    by: SolicitudAccesoScalarFieldEnum[] | SolicitudAccesoScalarFieldEnum
    having?: SolicitudAccesoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SolicitudAccesoCountAggregateInputType | true
    _min?: SolicitudAccesoMinAggregateInputType
    _max?: SolicitudAccesoMaxAggregateInputType
  }

  export type SolicitudAccesoGroupByOutputType = {
    id: string
    estudianteId: string | null
    nombre: string
    email: string
    telefono: string | null
    pais: string | null
    experiencia: string | null
    interes: string | null
    estado: $Enums.EstadoSolicitud
    fechaSolicitud: Date
    fechaRevision: Date | null
    motivoRechazo: string | null
    createdAt: Date
    _count: SolicitudAccesoCountAggregateOutputType | null
    _min: SolicitudAccesoMinAggregateOutputType | null
    _max: SolicitudAccesoMaxAggregateOutputType | null
  }

  type GetSolicitudAccesoGroupByPayload<T extends SolicitudAccesoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SolicitudAccesoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SolicitudAccesoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SolicitudAccesoGroupByOutputType[P]>
            : GetScalarType<T[P], SolicitudAccesoGroupByOutputType[P]>
        }
      >
    >


  export type SolicitudAccesoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estudianteId?: boolean
    nombre?: boolean
    email?: boolean
    telefono?: boolean
    pais?: boolean
    experiencia?: boolean
    interes?: boolean
    estado?: boolean
    fechaSolicitud?: boolean
    fechaRevision?: boolean
    motivoRechazo?: boolean
    createdAt?: boolean
    estudiante?: boolean | SolicitudAcceso$estudianteArgs<ExtArgs>
  }, ExtArgs["result"]["solicitudAcceso"]>

  export type SolicitudAccesoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estudianteId?: boolean
    nombre?: boolean
    email?: boolean
    telefono?: boolean
    pais?: boolean
    experiencia?: boolean
    interes?: boolean
    estado?: boolean
    fechaSolicitud?: boolean
    fechaRevision?: boolean
    motivoRechazo?: boolean
    createdAt?: boolean
    estudiante?: boolean | SolicitudAcceso$estudianteArgs<ExtArgs>
  }, ExtArgs["result"]["solicitudAcceso"]>

  export type SolicitudAccesoSelectScalar = {
    id?: boolean
    estudianteId?: boolean
    nombre?: boolean
    email?: boolean
    telefono?: boolean
    pais?: boolean
    experiencia?: boolean
    interes?: boolean
    estado?: boolean
    fechaSolicitud?: boolean
    fechaRevision?: boolean
    motivoRechazo?: boolean
    createdAt?: boolean
  }

  export type SolicitudAccesoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | SolicitudAcceso$estudianteArgs<ExtArgs>
  }
  export type SolicitudAccesoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | SolicitudAcceso$estudianteArgs<ExtArgs>
  }

  export type $SolicitudAccesoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SolicitudAcceso"
    objects: {
      estudiante: Prisma.$EstudiantePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      estudianteId: string | null
      nombre: string
      email: string
      telefono: string | null
      pais: string | null
      experiencia: string | null
      interes: string | null
      estado: $Enums.EstadoSolicitud
      fechaSolicitud: Date
      fechaRevision: Date | null
      motivoRechazo: string | null
      createdAt: Date
    }, ExtArgs["result"]["solicitudAcceso"]>
    composites: {}
  }

  type SolicitudAccesoGetPayload<S extends boolean | null | undefined | SolicitudAccesoDefaultArgs> = $Result.GetResult<Prisma.$SolicitudAccesoPayload, S>

  type SolicitudAccesoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SolicitudAccesoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SolicitudAccesoCountAggregateInputType | true
    }

  export interface SolicitudAccesoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SolicitudAcceso'], meta: { name: 'SolicitudAcceso' } }
    /**
     * Find zero or one SolicitudAcceso that matches the filter.
     * @param {SolicitudAccesoFindUniqueArgs} args - Arguments to find a SolicitudAcceso
     * @example
     * // Get one SolicitudAcceso
     * const solicitudAcceso = await prisma.solicitudAcceso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SolicitudAccesoFindUniqueArgs>(args: SelectSubset<T, SolicitudAccesoFindUniqueArgs<ExtArgs>>): Prisma__SolicitudAccesoClient<$Result.GetResult<Prisma.$SolicitudAccesoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SolicitudAcceso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SolicitudAccesoFindUniqueOrThrowArgs} args - Arguments to find a SolicitudAcceso
     * @example
     * // Get one SolicitudAcceso
     * const solicitudAcceso = await prisma.solicitudAcceso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SolicitudAccesoFindUniqueOrThrowArgs>(args: SelectSubset<T, SolicitudAccesoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SolicitudAccesoClient<$Result.GetResult<Prisma.$SolicitudAccesoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SolicitudAcceso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitudAccesoFindFirstArgs} args - Arguments to find a SolicitudAcceso
     * @example
     * // Get one SolicitudAcceso
     * const solicitudAcceso = await prisma.solicitudAcceso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SolicitudAccesoFindFirstArgs>(args?: SelectSubset<T, SolicitudAccesoFindFirstArgs<ExtArgs>>): Prisma__SolicitudAccesoClient<$Result.GetResult<Prisma.$SolicitudAccesoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SolicitudAcceso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitudAccesoFindFirstOrThrowArgs} args - Arguments to find a SolicitudAcceso
     * @example
     * // Get one SolicitudAcceso
     * const solicitudAcceso = await prisma.solicitudAcceso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SolicitudAccesoFindFirstOrThrowArgs>(args?: SelectSubset<T, SolicitudAccesoFindFirstOrThrowArgs<ExtArgs>>): Prisma__SolicitudAccesoClient<$Result.GetResult<Prisma.$SolicitudAccesoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SolicitudAccesos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitudAccesoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SolicitudAccesos
     * const solicitudAccesos = await prisma.solicitudAcceso.findMany()
     * 
     * // Get first 10 SolicitudAccesos
     * const solicitudAccesos = await prisma.solicitudAcceso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const solicitudAccesoWithIdOnly = await prisma.solicitudAcceso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SolicitudAccesoFindManyArgs>(args?: SelectSubset<T, SolicitudAccesoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SolicitudAccesoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SolicitudAcceso.
     * @param {SolicitudAccesoCreateArgs} args - Arguments to create a SolicitudAcceso.
     * @example
     * // Create one SolicitudAcceso
     * const SolicitudAcceso = await prisma.solicitudAcceso.create({
     *   data: {
     *     // ... data to create a SolicitudAcceso
     *   }
     * })
     * 
     */
    create<T extends SolicitudAccesoCreateArgs>(args: SelectSubset<T, SolicitudAccesoCreateArgs<ExtArgs>>): Prisma__SolicitudAccesoClient<$Result.GetResult<Prisma.$SolicitudAccesoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SolicitudAccesos.
     * @param {SolicitudAccesoCreateManyArgs} args - Arguments to create many SolicitudAccesos.
     * @example
     * // Create many SolicitudAccesos
     * const solicitudAcceso = await prisma.solicitudAcceso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SolicitudAccesoCreateManyArgs>(args?: SelectSubset<T, SolicitudAccesoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SolicitudAccesos and returns the data saved in the database.
     * @param {SolicitudAccesoCreateManyAndReturnArgs} args - Arguments to create many SolicitudAccesos.
     * @example
     * // Create many SolicitudAccesos
     * const solicitudAcceso = await prisma.solicitudAcceso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SolicitudAccesos and only return the `id`
     * const solicitudAccesoWithIdOnly = await prisma.solicitudAcceso.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SolicitudAccesoCreateManyAndReturnArgs>(args?: SelectSubset<T, SolicitudAccesoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SolicitudAccesoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SolicitudAcceso.
     * @param {SolicitudAccesoDeleteArgs} args - Arguments to delete one SolicitudAcceso.
     * @example
     * // Delete one SolicitudAcceso
     * const SolicitudAcceso = await prisma.solicitudAcceso.delete({
     *   where: {
     *     // ... filter to delete one SolicitudAcceso
     *   }
     * })
     * 
     */
    delete<T extends SolicitudAccesoDeleteArgs>(args: SelectSubset<T, SolicitudAccesoDeleteArgs<ExtArgs>>): Prisma__SolicitudAccesoClient<$Result.GetResult<Prisma.$SolicitudAccesoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SolicitudAcceso.
     * @param {SolicitudAccesoUpdateArgs} args - Arguments to update one SolicitudAcceso.
     * @example
     * // Update one SolicitudAcceso
     * const solicitudAcceso = await prisma.solicitudAcceso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SolicitudAccesoUpdateArgs>(args: SelectSubset<T, SolicitudAccesoUpdateArgs<ExtArgs>>): Prisma__SolicitudAccesoClient<$Result.GetResult<Prisma.$SolicitudAccesoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SolicitudAccesos.
     * @param {SolicitudAccesoDeleteManyArgs} args - Arguments to filter SolicitudAccesos to delete.
     * @example
     * // Delete a few SolicitudAccesos
     * const { count } = await prisma.solicitudAcceso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SolicitudAccesoDeleteManyArgs>(args?: SelectSubset<T, SolicitudAccesoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SolicitudAccesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitudAccesoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SolicitudAccesos
     * const solicitudAcceso = await prisma.solicitudAcceso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SolicitudAccesoUpdateManyArgs>(args: SelectSubset<T, SolicitudAccesoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SolicitudAcceso.
     * @param {SolicitudAccesoUpsertArgs} args - Arguments to update or create a SolicitudAcceso.
     * @example
     * // Update or create a SolicitudAcceso
     * const solicitudAcceso = await prisma.solicitudAcceso.upsert({
     *   create: {
     *     // ... data to create a SolicitudAcceso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SolicitudAcceso we want to update
     *   }
     * })
     */
    upsert<T extends SolicitudAccesoUpsertArgs>(args: SelectSubset<T, SolicitudAccesoUpsertArgs<ExtArgs>>): Prisma__SolicitudAccesoClient<$Result.GetResult<Prisma.$SolicitudAccesoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SolicitudAccesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitudAccesoCountArgs} args - Arguments to filter SolicitudAccesos to count.
     * @example
     * // Count the number of SolicitudAccesos
     * const count = await prisma.solicitudAcceso.count({
     *   where: {
     *     // ... the filter for the SolicitudAccesos we want to count
     *   }
     * })
    **/
    count<T extends SolicitudAccesoCountArgs>(
      args?: Subset<T, SolicitudAccesoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SolicitudAccesoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SolicitudAcceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitudAccesoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SolicitudAccesoAggregateArgs>(args: Subset<T, SolicitudAccesoAggregateArgs>): Prisma.PrismaPromise<GetSolicitudAccesoAggregateType<T>>

    /**
     * Group by SolicitudAcceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitudAccesoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SolicitudAccesoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SolicitudAccesoGroupByArgs['orderBy'] }
        : { orderBy?: SolicitudAccesoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SolicitudAccesoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSolicitudAccesoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SolicitudAcceso model
   */
  readonly fields: SolicitudAccesoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SolicitudAcceso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SolicitudAccesoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiante<T extends SolicitudAcceso$estudianteArgs<ExtArgs> = {}>(args?: Subset<T, SolicitudAcceso$estudianteArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SolicitudAcceso model
   */ 
  interface SolicitudAccesoFieldRefs {
    readonly id: FieldRef<"SolicitudAcceso", 'String'>
    readonly estudianteId: FieldRef<"SolicitudAcceso", 'String'>
    readonly nombre: FieldRef<"SolicitudAcceso", 'String'>
    readonly email: FieldRef<"SolicitudAcceso", 'String'>
    readonly telefono: FieldRef<"SolicitudAcceso", 'String'>
    readonly pais: FieldRef<"SolicitudAcceso", 'String'>
    readonly experiencia: FieldRef<"SolicitudAcceso", 'String'>
    readonly interes: FieldRef<"SolicitudAcceso", 'String'>
    readonly estado: FieldRef<"SolicitudAcceso", 'EstadoSolicitud'>
    readonly fechaSolicitud: FieldRef<"SolicitudAcceso", 'DateTime'>
    readonly fechaRevision: FieldRef<"SolicitudAcceso", 'DateTime'>
    readonly motivoRechazo: FieldRef<"SolicitudAcceso", 'String'>
    readonly createdAt: FieldRef<"SolicitudAcceso", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SolicitudAcceso findUnique
   */
  export type SolicitudAccesoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitudAcceso
     */
    select?: SolicitudAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolicitudAccesoInclude<ExtArgs> | null
    /**
     * Filter, which SolicitudAcceso to fetch.
     */
    where: SolicitudAccesoWhereUniqueInput
  }

  /**
   * SolicitudAcceso findUniqueOrThrow
   */
  export type SolicitudAccesoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitudAcceso
     */
    select?: SolicitudAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolicitudAccesoInclude<ExtArgs> | null
    /**
     * Filter, which SolicitudAcceso to fetch.
     */
    where: SolicitudAccesoWhereUniqueInput
  }

  /**
   * SolicitudAcceso findFirst
   */
  export type SolicitudAccesoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitudAcceso
     */
    select?: SolicitudAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolicitudAccesoInclude<ExtArgs> | null
    /**
     * Filter, which SolicitudAcceso to fetch.
     */
    where?: SolicitudAccesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SolicitudAccesos to fetch.
     */
    orderBy?: SolicitudAccesoOrderByWithRelationInput | SolicitudAccesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SolicitudAccesos.
     */
    cursor?: SolicitudAccesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SolicitudAccesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SolicitudAccesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SolicitudAccesos.
     */
    distinct?: SolicitudAccesoScalarFieldEnum | SolicitudAccesoScalarFieldEnum[]
  }

  /**
   * SolicitudAcceso findFirstOrThrow
   */
  export type SolicitudAccesoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitudAcceso
     */
    select?: SolicitudAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolicitudAccesoInclude<ExtArgs> | null
    /**
     * Filter, which SolicitudAcceso to fetch.
     */
    where?: SolicitudAccesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SolicitudAccesos to fetch.
     */
    orderBy?: SolicitudAccesoOrderByWithRelationInput | SolicitudAccesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SolicitudAccesos.
     */
    cursor?: SolicitudAccesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SolicitudAccesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SolicitudAccesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SolicitudAccesos.
     */
    distinct?: SolicitudAccesoScalarFieldEnum | SolicitudAccesoScalarFieldEnum[]
  }

  /**
   * SolicitudAcceso findMany
   */
  export type SolicitudAccesoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitudAcceso
     */
    select?: SolicitudAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolicitudAccesoInclude<ExtArgs> | null
    /**
     * Filter, which SolicitudAccesos to fetch.
     */
    where?: SolicitudAccesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SolicitudAccesos to fetch.
     */
    orderBy?: SolicitudAccesoOrderByWithRelationInput | SolicitudAccesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SolicitudAccesos.
     */
    cursor?: SolicitudAccesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SolicitudAccesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SolicitudAccesos.
     */
    skip?: number
    distinct?: SolicitudAccesoScalarFieldEnum | SolicitudAccesoScalarFieldEnum[]
  }

  /**
   * SolicitudAcceso create
   */
  export type SolicitudAccesoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitudAcceso
     */
    select?: SolicitudAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolicitudAccesoInclude<ExtArgs> | null
    /**
     * The data needed to create a SolicitudAcceso.
     */
    data: XOR<SolicitudAccesoCreateInput, SolicitudAccesoUncheckedCreateInput>
  }

  /**
   * SolicitudAcceso createMany
   */
  export type SolicitudAccesoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SolicitudAccesos.
     */
    data: SolicitudAccesoCreateManyInput | SolicitudAccesoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SolicitudAcceso createManyAndReturn
   */
  export type SolicitudAccesoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitudAcceso
     */
    select?: SolicitudAccesoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SolicitudAccesos.
     */
    data: SolicitudAccesoCreateManyInput | SolicitudAccesoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolicitudAccesoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SolicitudAcceso update
   */
  export type SolicitudAccesoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitudAcceso
     */
    select?: SolicitudAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolicitudAccesoInclude<ExtArgs> | null
    /**
     * The data needed to update a SolicitudAcceso.
     */
    data: XOR<SolicitudAccesoUpdateInput, SolicitudAccesoUncheckedUpdateInput>
    /**
     * Choose, which SolicitudAcceso to update.
     */
    where: SolicitudAccesoWhereUniqueInput
  }

  /**
   * SolicitudAcceso updateMany
   */
  export type SolicitudAccesoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SolicitudAccesos.
     */
    data: XOR<SolicitudAccesoUpdateManyMutationInput, SolicitudAccesoUncheckedUpdateManyInput>
    /**
     * Filter which SolicitudAccesos to update
     */
    where?: SolicitudAccesoWhereInput
  }

  /**
   * SolicitudAcceso upsert
   */
  export type SolicitudAccesoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitudAcceso
     */
    select?: SolicitudAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolicitudAccesoInclude<ExtArgs> | null
    /**
     * The filter to search for the SolicitudAcceso to update in case it exists.
     */
    where: SolicitudAccesoWhereUniqueInput
    /**
     * In case the SolicitudAcceso found by the `where` argument doesn't exist, create a new SolicitudAcceso with this data.
     */
    create: XOR<SolicitudAccesoCreateInput, SolicitudAccesoUncheckedCreateInput>
    /**
     * In case the SolicitudAcceso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SolicitudAccesoUpdateInput, SolicitudAccesoUncheckedUpdateInput>
  }

  /**
   * SolicitudAcceso delete
   */
  export type SolicitudAccesoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitudAcceso
     */
    select?: SolicitudAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolicitudAccesoInclude<ExtArgs> | null
    /**
     * Filter which SolicitudAcceso to delete.
     */
    where: SolicitudAccesoWhereUniqueInput
  }

  /**
   * SolicitudAcceso deleteMany
   */
  export type SolicitudAccesoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SolicitudAccesos to delete
     */
    where?: SolicitudAccesoWhereInput
  }

  /**
   * SolicitudAcceso.estudiante
   */
  export type SolicitudAcceso$estudianteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    where?: EstudianteWhereInput
  }

  /**
   * SolicitudAcceso without action
   */
  export type SolicitudAccesoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitudAcceso
     */
    select?: SolicitudAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolicitudAccesoInclude<ExtArgs> | null
  }


  /**
   * Model Modulo
   */

  export type AggregateModulo = {
    _count: ModuloCountAggregateOutputType | null
    _avg: ModuloAvgAggregateOutputType | null
    _sum: ModuloSumAggregateOutputType | null
    _min: ModuloMinAggregateOutputType | null
    _max: ModuloMaxAggregateOutputType | null
  }

  export type ModuloAvgAggregateOutputType = {
    orden: number | null
  }

  export type ModuloSumAggregateOutputType = {
    orden: number | null
  }

  export type ModuloMinAggregateOutputType = {
    id: string | null
    titulo: string | null
    descripcion: string | null
    orden: number | null
    moduloPrevioId: string | null
    estado: $Enums.EstadoModulo | null
    duracion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuloMaxAggregateOutputType = {
    id: string | null
    titulo: string | null
    descripcion: string | null
    orden: number | null
    moduloPrevioId: string | null
    estado: $Enums.EstadoModulo | null
    duracion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuloCountAggregateOutputType = {
    id: number
    titulo: number
    descripcion: number
    orden: number
    moduloPrevioId: number
    contenido: number
    estado: number
    duracion: number
    objetivos: number
    ejercicio: number
    recursos: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModuloAvgAggregateInputType = {
    orden?: true
  }

  export type ModuloSumAggregateInputType = {
    orden?: true
  }

  export type ModuloMinAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    orden?: true
    moduloPrevioId?: true
    estado?: true
    duracion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuloMaxAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    orden?: true
    moduloPrevioId?: true
    estado?: true
    duracion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuloCountAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    orden?: true
    moduloPrevioId?: true
    contenido?: true
    estado?: true
    duracion?: true
    objetivos?: true
    ejercicio?: true
    recursos?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModuloAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modulo to aggregate.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modulos
    **/
    _count?: true | ModuloCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuloAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuloSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuloMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuloMaxAggregateInputType
  }

  export type GetModuloAggregateType<T extends ModuloAggregateArgs> = {
        [P in keyof T & keyof AggregateModulo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModulo[P]>
      : GetScalarType<T[P], AggregateModulo[P]>
  }




  export type ModuloGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloWhereInput
    orderBy?: ModuloOrderByWithAggregationInput | ModuloOrderByWithAggregationInput[]
    by: ModuloScalarFieldEnum[] | ModuloScalarFieldEnum
    having?: ModuloScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuloCountAggregateInputType | true
    _avg?: ModuloAvgAggregateInputType
    _sum?: ModuloSumAggregateInputType
    _min?: ModuloMinAggregateInputType
    _max?: ModuloMaxAggregateInputType
  }

  export type ModuloGroupByOutputType = {
    id: string
    titulo: string
    descripcion: string | null
    orden: number
    moduloPrevioId: string | null
    contenido: JsonValue | null
    estado: $Enums.EstadoModulo
    duracion: string | null
    objetivos: string[]
    ejercicio: JsonValue | null
    recursos: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ModuloCountAggregateOutputType | null
    _avg: ModuloAvgAggregateOutputType | null
    _sum: ModuloSumAggregateOutputType | null
    _min: ModuloMinAggregateOutputType | null
    _max: ModuloMaxAggregateOutputType | null
  }

  type GetModuloGroupByPayload<T extends ModuloGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuloGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuloGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuloGroupByOutputType[P]>
            : GetScalarType<T[P], ModuloGroupByOutputType[P]>
        }
      >
    >


  export type ModuloSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    orden?: boolean
    moduloPrevioId?: boolean
    contenido?: boolean
    estado?: boolean
    duracion?: boolean
    objetivos?: boolean
    ejercicio?: boolean
    recursos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    progreso?: boolean | Modulo$progresoArgs<ExtArgs>
    _count?: boolean | ModuloCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulo"]>

  export type ModuloSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    orden?: boolean
    moduloPrevioId?: boolean
    contenido?: boolean
    estado?: boolean
    duracion?: boolean
    objetivos?: boolean
    ejercicio?: boolean
    recursos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["modulo"]>

  export type ModuloSelectScalar = {
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    orden?: boolean
    moduloPrevioId?: boolean
    contenido?: boolean
    estado?: boolean
    duracion?: boolean
    objetivos?: boolean
    ejercicio?: boolean
    recursos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModuloInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progreso?: boolean | Modulo$progresoArgs<ExtArgs>
    _count?: boolean | ModuloCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuloIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ModuloPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Modulo"
    objects: {
      progreso: Prisma.$ProgresoEstudiantePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titulo: string
      descripcion: string | null
      orden: number
      moduloPrevioId: string | null
      contenido: Prisma.JsonValue | null
      estado: $Enums.EstadoModulo
      duracion: string | null
      objetivos: string[]
      ejercicio: Prisma.JsonValue | null
      recursos: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["modulo"]>
    composites: {}
  }

  type ModuloGetPayload<S extends boolean | null | undefined | ModuloDefaultArgs> = $Result.GetResult<Prisma.$ModuloPayload, S>

  type ModuloCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuloFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuloCountAggregateInputType | true
    }

  export interface ModuloDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Modulo'], meta: { name: 'Modulo' } }
    /**
     * Find zero or one Modulo that matches the filter.
     * @param {ModuloFindUniqueArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuloFindUniqueArgs>(args: SelectSubset<T, ModuloFindUniqueArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Modulo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModuloFindUniqueOrThrowArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuloFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuloFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Modulo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindFirstArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuloFindFirstArgs>(args?: SelectSubset<T, ModuloFindFirstArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Modulo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindFirstOrThrowArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuloFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuloFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Modulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modulos
     * const modulos = await prisma.modulo.findMany()
     * 
     * // Get first 10 Modulos
     * const modulos = await prisma.modulo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduloWithIdOnly = await prisma.modulo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuloFindManyArgs>(args?: SelectSubset<T, ModuloFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Modulo.
     * @param {ModuloCreateArgs} args - Arguments to create a Modulo.
     * @example
     * // Create one Modulo
     * const Modulo = await prisma.modulo.create({
     *   data: {
     *     // ... data to create a Modulo
     *   }
     * })
     * 
     */
    create<T extends ModuloCreateArgs>(args: SelectSubset<T, ModuloCreateArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Modulos.
     * @param {ModuloCreateManyArgs} args - Arguments to create many Modulos.
     * @example
     * // Create many Modulos
     * const modulo = await prisma.modulo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuloCreateManyArgs>(args?: SelectSubset<T, ModuloCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modulos and returns the data saved in the database.
     * @param {ModuloCreateManyAndReturnArgs} args - Arguments to create many Modulos.
     * @example
     * // Create many Modulos
     * const modulo = await prisma.modulo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modulos and only return the `id`
     * const moduloWithIdOnly = await prisma.modulo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuloCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuloCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Modulo.
     * @param {ModuloDeleteArgs} args - Arguments to delete one Modulo.
     * @example
     * // Delete one Modulo
     * const Modulo = await prisma.modulo.delete({
     *   where: {
     *     // ... filter to delete one Modulo
     *   }
     * })
     * 
     */
    delete<T extends ModuloDeleteArgs>(args: SelectSubset<T, ModuloDeleteArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Modulo.
     * @param {ModuloUpdateArgs} args - Arguments to update one Modulo.
     * @example
     * // Update one Modulo
     * const modulo = await prisma.modulo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuloUpdateArgs>(args: SelectSubset<T, ModuloUpdateArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Modulos.
     * @param {ModuloDeleteManyArgs} args - Arguments to filter Modulos to delete.
     * @example
     * // Delete a few Modulos
     * const { count } = await prisma.modulo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuloDeleteManyArgs>(args?: SelectSubset<T, ModuloDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modulos
     * const modulo = await prisma.modulo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuloUpdateManyArgs>(args: SelectSubset<T, ModuloUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Modulo.
     * @param {ModuloUpsertArgs} args - Arguments to update or create a Modulo.
     * @example
     * // Update or create a Modulo
     * const modulo = await prisma.modulo.upsert({
     *   create: {
     *     // ... data to create a Modulo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Modulo we want to update
     *   }
     * })
     */
    upsert<T extends ModuloUpsertArgs>(args: SelectSubset<T, ModuloUpsertArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloCountArgs} args - Arguments to filter Modulos to count.
     * @example
     * // Count the number of Modulos
     * const count = await prisma.modulo.count({
     *   where: {
     *     // ... the filter for the Modulos we want to count
     *   }
     * })
    **/
    count<T extends ModuloCountArgs>(
      args?: Subset<T, ModuloCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuloCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Modulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuloAggregateArgs>(args: Subset<T, ModuloAggregateArgs>): Prisma.PrismaPromise<GetModuloAggregateType<T>>

    /**
     * Group by Modulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuloGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuloGroupByArgs['orderBy'] }
        : { orderBy?: ModuloGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuloGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuloGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Modulo model
   */
  readonly fields: ModuloFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Modulo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuloClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    progreso<T extends Modulo$progresoArgs<ExtArgs> = {}>(args?: Subset<T, Modulo$progresoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgresoEstudiantePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Modulo model
   */ 
  interface ModuloFieldRefs {
    readonly id: FieldRef<"Modulo", 'String'>
    readonly titulo: FieldRef<"Modulo", 'String'>
    readonly descripcion: FieldRef<"Modulo", 'String'>
    readonly orden: FieldRef<"Modulo", 'Int'>
    readonly moduloPrevioId: FieldRef<"Modulo", 'String'>
    readonly contenido: FieldRef<"Modulo", 'Json'>
    readonly estado: FieldRef<"Modulo", 'EstadoModulo'>
    readonly duracion: FieldRef<"Modulo", 'String'>
    readonly objetivos: FieldRef<"Modulo", 'String[]'>
    readonly ejercicio: FieldRef<"Modulo", 'Json'>
    readonly recursos: FieldRef<"Modulo", 'Json'>
    readonly createdAt: FieldRef<"Modulo", 'DateTime'>
    readonly updatedAt: FieldRef<"Modulo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Modulo findUnique
   */
  export type ModuloFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where: ModuloWhereUniqueInput
  }

  /**
   * Modulo findUniqueOrThrow
   */
  export type ModuloFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where: ModuloWhereUniqueInput
  }

  /**
   * Modulo findFirst
   */
  export type ModuloFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modulos.
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modulos.
     */
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }

  /**
   * Modulo findFirstOrThrow
   */
  export type ModuloFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modulos.
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modulos.
     */
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }

  /**
   * Modulo findMany
   */
  export type ModuloFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * Filter, which Modulos to fetch.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modulos.
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }

  /**
   * Modulo create
   */
  export type ModuloCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * The data needed to create a Modulo.
     */
    data: XOR<ModuloCreateInput, ModuloUncheckedCreateInput>
  }

  /**
   * Modulo createMany
   */
  export type ModuloCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modulos.
     */
    data: ModuloCreateManyInput | ModuloCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Modulo createManyAndReturn
   */
  export type ModuloCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Modulos.
     */
    data: ModuloCreateManyInput | ModuloCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Modulo update
   */
  export type ModuloUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * The data needed to update a Modulo.
     */
    data: XOR<ModuloUpdateInput, ModuloUncheckedUpdateInput>
    /**
     * Choose, which Modulo to update.
     */
    where: ModuloWhereUniqueInput
  }

  /**
   * Modulo updateMany
   */
  export type ModuloUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modulos.
     */
    data: XOR<ModuloUpdateManyMutationInput, ModuloUncheckedUpdateManyInput>
    /**
     * Filter which Modulos to update
     */
    where?: ModuloWhereInput
  }

  /**
   * Modulo upsert
   */
  export type ModuloUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * The filter to search for the Modulo to update in case it exists.
     */
    where: ModuloWhereUniqueInput
    /**
     * In case the Modulo found by the `where` argument doesn't exist, create a new Modulo with this data.
     */
    create: XOR<ModuloCreateInput, ModuloUncheckedCreateInput>
    /**
     * In case the Modulo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuloUpdateInput, ModuloUncheckedUpdateInput>
  }

  /**
   * Modulo delete
   */
  export type ModuloDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
    /**
     * Filter which Modulo to delete.
     */
    where: ModuloWhereUniqueInput
  }

  /**
   * Modulo deleteMany
   */
  export type ModuloDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modulos to delete
     */
    where?: ModuloWhereInput
  }

  /**
   * Modulo.progreso
   */
  export type Modulo$progresoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresoEstudiante
     */
    select?: ProgresoEstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresoEstudianteInclude<ExtArgs> | null
    where?: ProgresoEstudianteWhereInput
    orderBy?: ProgresoEstudianteOrderByWithRelationInput | ProgresoEstudianteOrderByWithRelationInput[]
    cursor?: ProgresoEstudianteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgresoEstudianteScalarFieldEnum | ProgresoEstudianteScalarFieldEnum[]
  }

  /**
   * Modulo without action
   */
  export type ModuloDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuloInclude<ExtArgs> | null
  }


  /**
   * Model ProgresoEstudiante
   */

  export type AggregateProgresoEstudiante = {
    _count: ProgresoEstudianteCountAggregateOutputType | null
    _avg: ProgresoEstudianteAvgAggregateOutputType | null
    _sum: ProgresoEstudianteSumAggregateOutputType | null
    _min: ProgresoEstudianteMinAggregateOutputType | null
    _max: ProgresoEstudianteMaxAggregateOutputType | null
  }

  export type ProgresoEstudianteAvgAggregateOutputType = {
    completudPorcentaje: number | null
  }

  export type ProgresoEstudianteSumAggregateOutputType = {
    completudPorcentaje: number | null
  }

  export type ProgresoEstudianteMinAggregateOutputType = {
    id: string | null
    estudianteId: string | null
    moduloId: string | null
    completudPorcentaje: number | null
    fechaCompletado: Date | null
    ultimaActividad: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgresoEstudianteMaxAggregateOutputType = {
    id: string | null
    estudianteId: string | null
    moduloId: string | null
    completudPorcentaje: number | null
    fechaCompletado: Date | null
    ultimaActividad: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgresoEstudianteCountAggregateOutputType = {
    id: number
    estudianteId: number
    moduloId: number
    completudPorcentaje: number
    fechaCompletado: number
    ultimaActividad: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgresoEstudianteAvgAggregateInputType = {
    completudPorcentaje?: true
  }

  export type ProgresoEstudianteSumAggregateInputType = {
    completudPorcentaje?: true
  }

  export type ProgresoEstudianteMinAggregateInputType = {
    id?: true
    estudianteId?: true
    moduloId?: true
    completudPorcentaje?: true
    fechaCompletado?: true
    ultimaActividad?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgresoEstudianteMaxAggregateInputType = {
    id?: true
    estudianteId?: true
    moduloId?: true
    completudPorcentaje?: true
    fechaCompletado?: true
    ultimaActividad?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgresoEstudianteCountAggregateInputType = {
    id?: true
    estudianteId?: true
    moduloId?: true
    completudPorcentaje?: true
    fechaCompletado?: true
    ultimaActividad?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgresoEstudianteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgresoEstudiante to aggregate.
     */
    where?: ProgresoEstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgresoEstudiantes to fetch.
     */
    orderBy?: ProgresoEstudianteOrderByWithRelationInput | ProgresoEstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgresoEstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgresoEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgresoEstudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgresoEstudiantes
    **/
    _count?: true | ProgresoEstudianteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgresoEstudianteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgresoEstudianteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgresoEstudianteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgresoEstudianteMaxAggregateInputType
  }

  export type GetProgresoEstudianteAggregateType<T extends ProgresoEstudianteAggregateArgs> = {
        [P in keyof T & keyof AggregateProgresoEstudiante]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgresoEstudiante[P]>
      : GetScalarType<T[P], AggregateProgresoEstudiante[P]>
  }




  export type ProgresoEstudianteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgresoEstudianteWhereInput
    orderBy?: ProgresoEstudianteOrderByWithAggregationInput | ProgresoEstudianteOrderByWithAggregationInput[]
    by: ProgresoEstudianteScalarFieldEnum[] | ProgresoEstudianteScalarFieldEnum
    having?: ProgresoEstudianteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgresoEstudianteCountAggregateInputType | true
    _avg?: ProgresoEstudianteAvgAggregateInputType
    _sum?: ProgresoEstudianteSumAggregateInputType
    _min?: ProgresoEstudianteMinAggregateInputType
    _max?: ProgresoEstudianteMaxAggregateInputType
  }

  export type ProgresoEstudianteGroupByOutputType = {
    id: string
    estudianteId: string
    moduloId: string
    completudPorcentaje: number
    fechaCompletado: Date | null
    ultimaActividad: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProgresoEstudianteCountAggregateOutputType | null
    _avg: ProgresoEstudianteAvgAggregateOutputType | null
    _sum: ProgresoEstudianteSumAggregateOutputType | null
    _min: ProgresoEstudianteMinAggregateOutputType | null
    _max: ProgresoEstudianteMaxAggregateOutputType | null
  }

  type GetProgresoEstudianteGroupByPayload<T extends ProgresoEstudianteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgresoEstudianteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgresoEstudianteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgresoEstudianteGroupByOutputType[P]>
            : GetScalarType<T[P], ProgresoEstudianteGroupByOutputType[P]>
        }
      >
    >


  export type ProgresoEstudianteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estudianteId?: boolean
    moduloId?: boolean
    completudPorcentaje?: boolean
    fechaCompletado?: boolean
    ultimaActividad?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progresoEstudiante"]>

  export type ProgresoEstudianteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estudianteId?: boolean
    moduloId?: boolean
    completudPorcentaje?: boolean
    fechaCompletado?: boolean
    ultimaActividad?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progresoEstudiante"]>

  export type ProgresoEstudianteSelectScalar = {
    id?: boolean
    estudianteId?: boolean
    moduloId?: boolean
    completudPorcentaje?: boolean
    fechaCompletado?: boolean
    ultimaActividad?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProgresoEstudianteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }
  export type ProgresoEstudianteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    modulo?: boolean | ModuloDefaultArgs<ExtArgs>
  }

  export type $ProgresoEstudiantePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgresoEstudiante"
    objects: {
      estudiante: Prisma.$EstudiantePayload<ExtArgs>
      modulo: Prisma.$ModuloPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      estudianteId: string
      moduloId: string
      completudPorcentaje: number
      fechaCompletado: Date | null
      ultimaActividad: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["progresoEstudiante"]>
    composites: {}
  }

  type ProgresoEstudianteGetPayload<S extends boolean | null | undefined | ProgresoEstudianteDefaultArgs> = $Result.GetResult<Prisma.$ProgresoEstudiantePayload, S>

  type ProgresoEstudianteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgresoEstudianteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgresoEstudianteCountAggregateInputType | true
    }

  export interface ProgresoEstudianteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgresoEstudiante'], meta: { name: 'ProgresoEstudiante' } }
    /**
     * Find zero or one ProgresoEstudiante that matches the filter.
     * @param {ProgresoEstudianteFindUniqueArgs} args - Arguments to find a ProgresoEstudiante
     * @example
     * // Get one ProgresoEstudiante
     * const progresoEstudiante = await prisma.progresoEstudiante.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgresoEstudianteFindUniqueArgs>(args: SelectSubset<T, ProgresoEstudianteFindUniqueArgs<ExtArgs>>): Prisma__ProgresoEstudianteClient<$Result.GetResult<Prisma.$ProgresoEstudiantePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProgresoEstudiante that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgresoEstudianteFindUniqueOrThrowArgs} args - Arguments to find a ProgresoEstudiante
     * @example
     * // Get one ProgresoEstudiante
     * const progresoEstudiante = await prisma.progresoEstudiante.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgresoEstudianteFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgresoEstudianteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgresoEstudianteClient<$Result.GetResult<Prisma.$ProgresoEstudiantePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProgresoEstudiante that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgresoEstudianteFindFirstArgs} args - Arguments to find a ProgresoEstudiante
     * @example
     * // Get one ProgresoEstudiante
     * const progresoEstudiante = await prisma.progresoEstudiante.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgresoEstudianteFindFirstArgs>(args?: SelectSubset<T, ProgresoEstudianteFindFirstArgs<ExtArgs>>): Prisma__ProgresoEstudianteClient<$Result.GetResult<Prisma.$ProgresoEstudiantePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProgresoEstudiante that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgresoEstudianteFindFirstOrThrowArgs} args - Arguments to find a ProgresoEstudiante
     * @example
     * // Get one ProgresoEstudiante
     * const progresoEstudiante = await prisma.progresoEstudiante.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgresoEstudianteFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgresoEstudianteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgresoEstudianteClient<$Result.GetResult<Prisma.$ProgresoEstudiantePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProgresoEstudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgresoEstudianteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgresoEstudiantes
     * const progresoEstudiantes = await prisma.progresoEstudiante.findMany()
     * 
     * // Get first 10 ProgresoEstudiantes
     * const progresoEstudiantes = await prisma.progresoEstudiante.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const progresoEstudianteWithIdOnly = await prisma.progresoEstudiante.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgresoEstudianteFindManyArgs>(args?: SelectSubset<T, ProgresoEstudianteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgresoEstudiantePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProgresoEstudiante.
     * @param {ProgresoEstudianteCreateArgs} args - Arguments to create a ProgresoEstudiante.
     * @example
     * // Create one ProgresoEstudiante
     * const ProgresoEstudiante = await prisma.progresoEstudiante.create({
     *   data: {
     *     // ... data to create a ProgresoEstudiante
     *   }
     * })
     * 
     */
    create<T extends ProgresoEstudianteCreateArgs>(args: SelectSubset<T, ProgresoEstudianteCreateArgs<ExtArgs>>): Prisma__ProgresoEstudianteClient<$Result.GetResult<Prisma.$ProgresoEstudiantePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProgresoEstudiantes.
     * @param {ProgresoEstudianteCreateManyArgs} args - Arguments to create many ProgresoEstudiantes.
     * @example
     * // Create many ProgresoEstudiantes
     * const progresoEstudiante = await prisma.progresoEstudiante.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgresoEstudianteCreateManyArgs>(args?: SelectSubset<T, ProgresoEstudianteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgresoEstudiantes and returns the data saved in the database.
     * @param {ProgresoEstudianteCreateManyAndReturnArgs} args - Arguments to create many ProgresoEstudiantes.
     * @example
     * // Create many ProgresoEstudiantes
     * const progresoEstudiante = await prisma.progresoEstudiante.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgresoEstudiantes and only return the `id`
     * const progresoEstudianteWithIdOnly = await prisma.progresoEstudiante.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgresoEstudianteCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgresoEstudianteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgresoEstudiantePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProgresoEstudiante.
     * @param {ProgresoEstudianteDeleteArgs} args - Arguments to delete one ProgresoEstudiante.
     * @example
     * // Delete one ProgresoEstudiante
     * const ProgresoEstudiante = await prisma.progresoEstudiante.delete({
     *   where: {
     *     // ... filter to delete one ProgresoEstudiante
     *   }
     * })
     * 
     */
    delete<T extends ProgresoEstudianteDeleteArgs>(args: SelectSubset<T, ProgresoEstudianteDeleteArgs<ExtArgs>>): Prisma__ProgresoEstudianteClient<$Result.GetResult<Prisma.$ProgresoEstudiantePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProgresoEstudiante.
     * @param {ProgresoEstudianteUpdateArgs} args - Arguments to update one ProgresoEstudiante.
     * @example
     * // Update one ProgresoEstudiante
     * const progresoEstudiante = await prisma.progresoEstudiante.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgresoEstudianteUpdateArgs>(args: SelectSubset<T, ProgresoEstudianteUpdateArgs<ExtArgs>>): Prisma__ProgresoEstudianteClient<$Result.GetResult<Prisma.$ProgresoEstudiantePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProgresoEstudiantes.
     * @param {ProgresoEstudianteDeleteManyArgs} args - Arguments to filter ProgresoEstudiantes to delete.
     * @example
     * // Delete a few ProgresoEstudiantes
     * const { count } = await prisma.progresoEstudiante.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgresoEstudianteDeleteManyArgs>(args?: SelectSubset<T, ProgresoEstudianteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgresoEstudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgresoEstudianteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgresoEstudiantes
     * const progresoEstudiante = await prisma.progresoEstudiante.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgresoEstudianteUpdateManyArgs>(args: SelectSubset<T, ProgresoEstudianteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgresoEstudiante.
     * @param {ProgresoEstudianteUpsertArgs} args - Arguments to update or create a ProgresoEstudiante.
     * @example
     * // Update or create a ProgresoEstudiante
     * const progresoEstudiante = await prisma.progresoEstudiante.upsert({
     *   create: {
     *     // ... data to create a ProgresoEstudiante
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgresoEstudiante we want to update
     *   }
     * })
     */
    upsert<T extends ProgresoEstudianteUpsertArgs>(args: SelectSubset<T, ProgresoEstudianteUpsertArgs<ExtArgs>>): Prisma__ProgresoEstudianteClient<$Result.GetResult<Prisma.$ProgresoEstudiantePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProgresoEstudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgresoEstudianteCountArgs} args - Arguments to filter ProgresoEstudiantes to count.
     * @example
     * // Count the number of ProgresoEstudiantes
     * const count = await prisma.progresoEstudiante.count({
     *   where: {
     *     // ... the filter for the ProgresoEstudiantes we want to count
     *   }
     * })
    **/
    count<T extends ProgresoEstudianteCountArgs>(
      args?: Subset<T, ProgresoEstudianteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgresoEstudianteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgresoEstudiante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgresoEstudianteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgresoEstudianteAggregateArgs>(args: Subset<T, ProgresoEstudianteAggregateArgs>): Prisma.PrismaPromise<GetProgresoEstudianteAggregateType<T>>

    /**
     * Group by ProgresoEstudiante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgresoEstudianteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgresoEstudianteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgresoEstudianteGroupByArgs['orderBy'] }
        : { orderBy?: ProgresoEstudianteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgresoEstudianteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgresoEstudianteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgresoEstudiante model
   */
  readonly fields: ProgresoEstudianteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgresoEstudiante.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgresoEstudianteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiante<T extends EstudianteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstudianteDefaultArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    modulo<T extends ModuloDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuloDefaultArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgresoEstudiante model
   */ 
  interface ProgresoEstudianteFieldRefs {
    readonly id: FieldRef<"ProgresoEstudiante", 'String'>
    readonly estudianteId: FieldRef<"ProgresoEstudiante", 'String'>
    readonly moduloId: FieldRef<"ProgresoEstudiante", 'String'>
    readonly completudPorcentaje: FieldRef<"ProgresoEstudiante", 'Int'>
    readonly fechaCompletado: FieldRef<"ProgresoEstudiante", 'DateTime'>
    readonly ultimaActividad: FieldRef<"ProgresoEstudiante", 'DateTime'>
    readonly createdAt: FieldRef<"ProgresoEstudiante", 'DateTime'>
    readonly updatedAt: FieldRef<"ProgresoEstudiante", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProgresoEstudiante findUnique
   */
  export type ProgresoEstudianteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresoEstudiante
     */
    select?: ProgresoEstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresoEstudianteInclude<ExtArgs> | null
    /**
     * Filter, which ProgresoEstudiante to fetch.
     */
    where: ProgresoEstudianteWhereUniqueInput
  }

  /**
   * ProgresoEstudiante findUniqueOrThrow
   */
  export type ProgresoEstudianteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresoEstudiante
     */
    select?: ProgresoEstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresoEstudianteInclude<ExtArgs> | null
    /**
     * Filter, which ProgresoEstudiante to fetch.
     */
    where: ProgresoEstudianteWhereUniqueInput
  }

  /**
   * ProgresoEstudiante findFirst
   */
  export type ProgresoEstudianteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresoEstudiante
     */
    select?: ProgresoEstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresoEstudianteInclude<ExtArgs> | null
    /**
     * Filter, which ProgresoEstudiante to fetch.
     */
    where?: ProgresoEstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgresoEstudiantes to fetch.
     */
    orderBy?: ProgresoEstudianteOrderByWithRelationInput | ProgresoEstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgresoEstudiantes.
     */
    cursor?: ProgresoEstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgresoEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgresoEstudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgresoEstudiantes.
     */
    distinct?: ProgresoEstudianteScalarFieldEnum | ProgresoEstudianteScalarFieldEnum[]
  }

  /**
   * ProgresoEstudiante findFirstOrThrow
   */
  export type ProgresoEstudianteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresoEstudiante
     */
    select?: ProgresoEstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresoEstudianteInclude<ExtArgs> | null
    /**
     * Filter, which ProgresoEstudiante to fetch.
     */
    where?: ProgresoEstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgresoEstudiantes to fetch.
     */
    orderBy?: ProgresoEstudianteOrderByWithRelationInput | ProgresoEstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgresoEstudiantes.
     */
    cursor?: ProgresoEstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgresoEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgresoEstudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgresoEstudiantes.
     */
    distinct?: ProgresoEstudianteScalarFieldEnum | ProgresoEstudianteScalarFieldEnum[]
  }

  /**
   * ProgresoEstudiante findMany
   */
  export type ProgresoEstudianteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresoEstudiante
     */
    select?: ProgresoEstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresoEstudianteInclude<ExtArgs> | null
    /**
     * Filter, which ProgresoEstudiantes to fetch.
     */
    where?: ProgresoEstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgresoEstudiantes to fetch.
     */
    orderBy?: ProgresoEstudianteOrderByWithRelationInput | ProgresoEstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgresoEstudiantes.
     */
    cursor?: ProgresoEstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgresoEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgresoEstudiantes.
     */
    skip?: number
    distinct?: ProgresoEstudianteScalarFieldEnum | ProgresoEstudianteScalarFieldEnum[]
  }

  /**
   * ProgresoEstudiante create
   */
  export type ProgresoEstudianteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresoEstudiante
     */
    select?: ProgresoEstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresoEstudianteInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgresoEstudiante.
     */
    data: XOR<ProgresoEstudianteCreateInput, ProgresoEstudianteUncheckedCreateInput>
  }

  /**
   * ProgresoEstudiante createMany
   */
  export type ProgresoEstudianteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgresoEstudiantes.
     */
    data: ProgresoEstudianteCreateManyInput | ProgresoEstudianteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgresoEstudiante createManyAndReturn
   */
  export type ProgresoEstudianteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresoEstudiante
     */
    select?: ProgresoEstudianteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProgresoEstudiantes.
     */
    data: ProgresoEstudianteCreateManyInput | ProgresoEstudianteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresoEstudianteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgresoEstudiante update
   */
  export type ProgresoEstudianteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresoEstudiante
     */
    select?: ProgresoEstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresoEstudianteInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgresoEstudiante.
     */
    data: XOR<ProgresoEstudianteUpdateInput, ProgresoEstudianteUncheckedUpdateInput>
    /**
     * Choose, which ProgresoEstudiante to update.
     */
    where: ProgresoEstudianteWhereUniqueInput
  }

  /**
   * ProgresoEstudiante updateMany
   */
  export type ProgresoEstudianteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgresoEstudiantes.
     */
    data: XOR<ProgresoEstudianteUpdateManyMutationInput, ProgresoEstudianteUncheckedUpdateManyInput>
    /**
     * Filter which ProgresoEstudiantes to update
     */
    where?: ProgresoEstudianteWhereInput
  }

  /**
   * ProgresoEstudiante upsert
   */
  export type ProgresoEstudianteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresoEstudiante
     */
    select?: ProgresoEstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresoEstudianteInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgresoEstudiante to update in case it exists.
     */
    where: ProgresoEstudianteWhereUniqueInput
    /**
     * In case the ProgresoEstudiante found by the `where` argument doesn't exist, create a new ProgresoEstudiante with this data.
     */
    create: XOR<ProgresoEstudianteCreateInput, ProgresoEstudianteUncheckedCreateInput>
    /**
     * In case the ProgresoEstudiante was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgresoEstudianteUpdateInput, ProgresoEstudianteUncheckedUpdateInput>
  }

  /**
   * ProgresoEstudiante delete
   */
  export type ProgresoEstudianteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresoEstudiante
     */
    select?: ProgresoEstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresoEstudianteInclude<ExtArgs> | null
    /**
     * Filter which ProgresoEstudiante to delete.
     */
    where: ProgresoEstudianteWhereUniqueInput
  }

  /**
   * ProgresoEstudiante deleteMany
   */
  export type ProgresoEstudianteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgresoEstudiantes to delete
     */
    where?: ProgresoEstudianteWhereInput
  }

  /**
   * ProgresoEstudiante without action
   */
  export type ProgresoEstudianteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresoEstudiante
     */
    select?: ProgresoEstudianteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresoEstudianteInclude<ExtArgs> | null
  }


  /**
   * Model Pago
   */

  export type AggregatePago = {
    _count: PagoCountAggregateOutputType | null
    _avg: PagoAvgAggregateOutputType | null
    _sum: PagoSumAggregateOutputType | null
    _min: PagoMinAggregateOutputType | null
    _max: PagoMaxAggregateOutputType | null
  }

  export type PagoAvgAggregateOutputType = {
    monto: Decimal | null
  }

  export type PagoSumAggregateOutputType = {
    monto: Decimal | null
  }

  export type PagoMinAggregateOutputType = {
    id: string | null
    estudianteId: string | null
    monto: Decimal | null
    moneda: string | null
    proveedor: string | null
    referenciaExterna: string | null
    estado: $Enums.EstadoPagoTransaccion | null
    fechaPago: Date | null
    createdAt: Date | null
  }

  export type PagoMaxAggregateOutputType = {
    id: string | null
    estudianteId: string | null
    monto: Decimal | null
    moneda: string | null
    proveedor: string | null
    referenciaExterna: string | null
    estado: $Enums.EstadoPagoTransaccion | null
    fechaPago: Date | null
    createdAt: Date | null
  }

  export type PagoCountAggregateOutputType = {
    id: number
    estudianteId: number
    monto: number
    moneda: number
    proveedor: number
    referenciaExterna: number
    estado: number
    fechaPago: number
    createdAt: number
    _all: number
  }


  export type PagoAvgAggregateInputType = {
    monto?: true
  }

  export type PagoSumAggregateInputType = {
    monto?: true
  }

  export type PagoMinAggregateInputType = {
    id?: true
    estudianteId?: true
    monto?: true
    moneda?: true
    proveedor?: true
    referenciaExterna?: true
    estado?: true
    fechaPago?: true
    createdAt?: true
  }

  export type PagoMaxAggregateInputType = {
    id?: true
    estudianteId?: true
    monto?: true
    moneda?: true
    proveedor?: true
    referenciaExterna?: true
    estado?: true
    fechaPago?: true
    createdAt?: true
  }

  export type PagoCountAggregateInputType = {
    id?: true
    estudianteId?: true
    monto?: true
    moneda?: true
    proveedor?: true
    referenciaExterna?: true
    estado?: true
    fechaPago?: true
    createdAt?: true
    _all?: true
  }

  export type PagoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pago to aggregate.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pagos
    **/
    _count?: true | PagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagoMaxAggregateInputType
  }

  export type GetPagoAggregateType<T extends PagoAggregateArgs> = {
        [P in keyof T & keyof AggregatePago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePago[P]>
      : GetScalarType<T[P], AggregatePago[P]>
  }




  export type PagoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoWhereInput
    orderBy?: PagoOrderByWithAggregationInput | PagoOrderByWithAggregationInput[]
    by: PagoScalarFieldEnum[] | PagoScalarFieldEnum
    having?: PagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagoCountAggregateInputType | true
    _avg?: PagoAvgAggregateInputType
    _sum?: PagoSumAggregateInputType
    _min?: PagoMinAggregateInputType
    _max?: PagoMaxAggregateInputType
  }

  export type PagoGroupByOutputType = {
    id: string
    estudianteId: string
    monto: Decimal
    moneda: string
    proveedor: string
    referenciaExterna: string
    estado: $Enums.EstadoPagoTransaccion
    fechaPago: Date | null
    createdAt: Date
    _count: PagoCountAggregateOutputType | null
    _avg: PagoAvgAggregateOutputType | null
    _sum: PagoSumAggregateOutputType | null
    _min: PagoMinAggregateOutputType | null
    _max: PagoMaxAggregateOutputType | null
  }

  type GetPagoGroupByPayload<T extends PagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagoGroupByOutputType[P]>
            : GetScalarType<T[P], PagoGroupByOutputType[P]>
        }
      >
    >


  export type PagoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estudianteId?: boolean
    monto?: boolean
    moneda?: boolean
    proveedor?: boolean
    referenciaExterna?: boolean
    estado?: boolean
    fechaPago?: boolean
    createdAt?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type PagoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estudianteId?: boolean
    monto?: boolean
    moneda?: boolean
    proveedor?: boolean
    referenciaExterna?: boolean
    estado?: boolean
    fechaPago?: boolean
    createdAt?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type PagoSelectScalar = {
    id?: boolean
    estudianteId?: boolean
    monto?: boolean
    moneda?: boolean
    proveedor?: boolean
    referenciaExterna?: boolean
    estado?: boolean
    fechaPago?: boolean
    createdAt?: boolean
  }

  export type PagoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }
  export type PagoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }

  export type $PagoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pago"
    objects: {
      estudiante: Prisma.$EstudiantePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      estudianteId: string
      monto: Prisma.Decimal
      moneda: string
      proveedor: string
      referenciaExterna: string
      estado: $Enums.EstadoPagoTransaccion
      fechaPago: Date | null
      createdAt: Date
    }, ExtArgs["result"]["pago"]>
    composites: {}
  }

  type PagoGetPayload<S extends boolean | null | undefined | PagoDefaultArgs> = $Result.GetResult<Prisma.$PagoPayload, S>

  type PagoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PagoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PagoCountAggregateInputType | true
    }

  export interface PagoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pago'], meta: { name: 'Pago' } }
    /**
     * Find zero or one Pago that matches the filter.
     * @param {PagoFindUniqueArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagoFindUniqueArgs>(args: SelectSubset<T, PagoFindUniqueArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pago that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PagoFindUniqueOrThrowArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagoFindUniqueOrThrowArgs>(args: SelectSubset<T, PagoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoFindFirstArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagoFindFirstArgs>(args?: SelectSubset<T, PagoFindFirstArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pago that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoFindFirstOrThrowArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagoFindFirstOrThrowArgs>(args?: SelectSubset<T, PagoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagos
     * const pagos = await prisma.pago.findMany()
     * 
     * // Get first 10 Pagos
     * const pagos = await prisma.pago.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagoWithIdOnly = await prisma.pago.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PagoFindManyArgs>(args?: SelectSubset<T, PagoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pago.
     * @param {PagoCreateArgs} args - Arguments to create a Pago.
     * @example
     * // Create one Pago
     * const Pago = await prisma.pago.create({
     *   data: {
     *     // ... data to create a Pago
     *   }
     * })
     * 
     */
    create<T extends PagoCreateArgs>(args: SelectSubset<T, PagoCreateArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pagos.
     * @param {PagoCreateManyArgs} args - Arguments to create many Pagos.
     * @example
     * // Create many Pagos
     * const pago = await prisma.pago.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagoCreateManyArgs>(args?: SelectSubset<T, PagoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pagos and returns the data saved in the database.
     * @param {PagoCreateManyAndReturnArgs} args - Arguments to create many Pagos.
     * @example
     * // Create many Pagos
     * const pago = await prisma.pago.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pagos and only return the `id`
     * const pagoWithIdOnly = await prisma.pago.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PagoCreateManyAndReturnArgs>(args?: SelectSubset<T, PagoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pago.
     * @param {PagoDeleteArgs} args - Arguments to delete one Pago.
     * @example
     * // Delete one Pago
     * const Pago = await prisma.pago.delete({
     *   where: {
     *     // ... filter to delete one Pago
     *   }
     * })
     * 
     */
    delete<T extends PagoDeleteArgs>(args: SelectSubset<T, PagoDeleteArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pago.
     * @param {PagoUpdateArgs} args - Arguments to update one Pago.
     * @example
     * // Update one Pago
     * const pago = await prisma.pago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagoUpdateArgs>(args: SelectSubset<T, PagoUpdateArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pagos.
     * @param {PagoDeleteManyArgs} args - Arguments to filter Pagos to delete.
     * @example
     * // Delete a few Pagos
     * const { count } = await prisma.pago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagoDeleteManyArgs>(args?: SelectSubset<T, PagoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagos
     * const pago = await prisma.pago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagoUpdateManyArgs>(args: SelectSubset<T, PagoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pago.
     * @param {PagoUpsertArgs} args - Arguments to update or create a Pago.
     * @example
     * // Update or create a Pago
     * const pago = await prisma.pago.upsert({
     *   create: {
     *     // ... data to create a Pago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pago we want to update
     *   }
     * })
     */
    upsert<T extends PagoUpsertArgs>(args: SelectSubset<T, PagoUpsertArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoCountArgs} args - Arguments to filter Pagos to count.
     * @example
     * // Count the number of Pagos
     * const count = await prisma.pago.count({
     *   where: {
     *     // ... the filter for the Pagos we want to count
     *   }
     * })
    **/
    count<T extends PagoCountArgs>(
      args?: Subset<T, PagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagoAggregateArgs>(args: Subset<T, PagoAggregateArgs>): Prisma.PrismaPromise<GetPagoAggregateType<T>>

    /**
     * Group by Pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagoGroupByArgs['orderBy'] }
        : { orderBy?: PagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pago model
   */
  readonly fields: PagoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiante<T extends EstudianteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstudianteDefaultArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pago model
   */ 
  interface PagoFieldRefs {
    readonly id: FieldRef<"Pago", 'String'>
    readonly estudianteId: FieldRef<"Pago", 'String'>
    readonly monto: FieldRef<"Pago", 'Decimal'>
    readonly moneda: FieldRef<"Pago", 'String'>
    readonly proveedor: FieldRef<"Pago", 'String'>
    readonly referenciaExterna: FieldRef<"Pago", 'String'>
    readonly estado: FieldRef<"Pago", 'EstadoPagoTransaccion'>
    readonly fechaPago: FieldRef<"Pago", 'DateTime'>
    readonly createdAt: FieldRef<"Pago", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pago findUnique
   */
  export type PagoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago findUniqueOrThrow
   */
  export type PagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago findFirst
   */
  export type PagoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagos.
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagos.
     */
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Pago findFirstOrThrow
   */
  export type PagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagos.
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagos.
     */
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Pago findMany
   */
  export type PagoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pagos to fetch.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pagos.
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Pago create
   */
  export type PagoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pago.
     */
    data: XOR<PagoCreateInput, PagoUncheckedCreateInput>
  }

  /**
   * Pago createMany
   */
  export type PagoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pagos.
     */
    data: PagoCreateManyInput | PagoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pago createManyAndReturn
   */
  export type PagoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pagos.
     */
    data: PagoCreateManyInput | PagoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pago update
   */
  export type PagoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pago.
     */
    data: XOR<PagoUpdateInput, PagoUncheckedUpdateInput>
    /**
     * Choose, which Pago to update.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago updateMany
   */
  export type PagoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pagos.
     */
    data: XOR<PagoUpdateManyMutationInput, PagoUncheckedUpdateManyInput>
    /**
     * Filter which Pagos to update
     */
    where?: PagoWhereInput
  }

  /**
   * Pago upsert
   */
  export type PagoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pago to update in case it exists.
     */
    where: PagoWhereUniqueInput
    /**
     * In case the Pago found by the `where` argument doesn't exist, create a new Pago with this data.
     */
    create: XOR<PagoCreateInput, PagoUncheckedCreateInput>
    /**
     * In case the Pago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagoUpdateInput, PagoUncheckedUpdateInput>
  }

  /**
   * Pago delete
   */
  export type PagoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter which Pago to delete.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago deleteMany
   */
  export type PagoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagos to delete
     */
    where?: PagoWhereInput
  }

  /**
   * Pago without action
   */
  export type PagoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
  }


  /**
   * Model ConfiguracionProfesor
   */

  export type AggregateConfiguracionProfesor = {
    _count: ConfiguracionProfesorCountAggregateOutputType | null
    _avg: ConfiguracionProfesorAvgAggregateOutputType | null
    _sum: ConfiguracionProfesorSumAggregateOutputType | null
    _min: ConfiguracionProfesorMinAggregateOutputType | null
    _max: ConfiguracionProfesorMaxAggregateOutputType | null
  }

  export type ConfiguracionProfesorAvgAggregateOutputType = {
    precioCurso: Decimal | null
  }

  export type ConfiguracionProfesorSumAggregateOutputType = {
    precioCurso: Decimal | null
  }

  export type ConfiguracionProfesorMinAggregateOutputType = {
    id: string | null
    profesorId: string | null
    nombreCurso: string | null
    descripcionCurso: string | null
    precioCurso: Decimal | null
    moneda: string | null
    bioProfesor: string | null
    fotoProfesorUrl: string | null
    emailContacto: string | null
    whatsappNumero: string | null
    pais: string | null
    stripeSecretKey: string | null
    stripePublicKey: string | null
    stripeWebhookSecret: string | null
    emailNotificaciones: string | null
    notificarWhatsApp: boolean | null
    notificarEmail: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfiguracionProfesorMaxAggregateOutputType = {
    id: string | null
    profesorId: string | null
    nombreCurso: string | null
    descripcionCurso: string | null
    precioCurso: Decimal | null
    moneda: string | null
    bioProfesor: string | null
    fotoProfesorUrl: string | null
    emailContacto: string | null
    whatsappNumero: string | null
    pais: string | null
    stripeSecretKey: string | null
    stripePublicKey: string | null
    stripeWebhookSecret: string | null
    emailNotificaciones: string | null
    notificarWhatsApp: boolean | null
    notificarEmail: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfiguracionProfesorCountAggregateOutputType = {
    id: number
    profesorId: number
    nombreCurso: number
    descripcionCurso: number
    precioCurso: number
    moneda: number
    bioProfesor: number
    fotoProfesorUrl: number
    emailContacto: number
    whatsappNumero: number
    pais: number
    stripeSecretKey: number
    stripePublicKey: number
    stripeWebhookSecret: number
    emailNotificaciones: number
    notificarWhatsApp: number
    notificarEmail: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConfiguracionProfesorAvgAggregateInputType = {
    precioCurso?: true
  }

  export type ConfiguracionProfesorSumAggregateInputType = {
    precioCurso?: true
  }

  export type ConfiguracionProfesorMinAggregateInputType = {
    id?: true
    profesorId?: true
    nombreCurso?: true
    descripcionCurso?: true
    precioCurso?: true
    moneda?: true
    bioProfesor?: true
    fotoProfesorUrl?: true
    emailContacto?: true
    whatsappNumero?: true
    pais?: true
    stripeSecretKey?: true
    stripePublicKey?: true
    stripeWebhookSecret?: true
    emailNotificaciones?: true
    notificarWhatsApp?: true
    notificarEmail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfiguracionProfesorMaxAggregateInputType = {
    id?: true
    profesorId?: true
    nombreCurso?: true
    descripcionCurso?: true
    precioCurso?: true
    moneda?: true
    bioProfesor?: true
    fotoProfesorUrl?: true
    emailContacto?: true
    whatsappNumero?: true
    pais?: true
    stripeSecretKey?: true
    stripePublicKey?: true
    stripeWebhookSecret?: true
    emailNotificaciones?: true
    notificarWhatsApp?: true
    notificarEmail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfiguracionProfesorCountAggregateInputType = {
    id?: true
    profesorId?: true
    nombreCurso?: true
    descripcionCurso?: true
    precioCurso?: true
    moneda?: true
    bioProfesor?: true
    fotoProfesorUrl?: true
    emailContacto?: true
    whatsappNumero?: true
    pais?: true
    stripeSecretKey?: true
    stripePublicKey?: true
    stripeWebhookSecret?: true
    emailNotificaciones?: true
    notificarWhatsApp?: true
    notificarEmail?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConfiguracionProfesorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfiguracionProfesor to aggregate.
     */
    where?: ConfiguracionProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracionProfesors to fetch.
     */
    orderBy?: ConfiguracionProfesorOrderByWithRelationInput | ConfiguracionProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfiguracionProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracionProfesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracionProfesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfiguracionProfesors
    **/
    _count?: true | ConfiguracionProfesorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfiguracionProfesorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfiguracionProfesorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfiguracionProfesorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfiguracionProfesorMaxAggregateInputType
  }

  export type GetConfiguracionProfesorAggregateType<T extends ConfiguracionProfesorAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguracionProfesor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguracionProfesor[P]>
      : GetScalarType<T[P], AggregateConfiguracionProfesor[P]>
  }




  export type ConfiguracionProfesorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfiguracionProfesorWhereInput
    orderBy?: ConfiguracionProfesorOrderByWithAggregationInput | ConfiguracionProfesorOrderByWithAggregationInput[]
    by: ConfiguracionProfesorScalarFieldEnum[] | ConfiguracionProfesorScalarFieldEnum
    having?: ConfiguracionProfesorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfiguracionProfesorCountAggregateInputType | true
    _avg?: ConfiguracionProfesorAvgAggregateInputType
    _sum?: ConfiguracionProfesorSumAggregateInputType
    _min?: ConfiguracionProfesorMinAggregateInputType
    _max?: ConfiguracionProfesorMaxAggregateInputType
  }

  export type ConfiguracionProfesorGroupByOutputType = {
    id: string
    profesorId: string
    nombreCurso: string
    descripcionCurso: string | null
    precioCurso: Decimal
    moneda: string
    bioProfesor: string | null
    fotoProfesorUrl: string | null
    emailContacto: string | null
    whatsappNumero: string | null
    pais: string | null
    stripeSecretKey: string | null
    stripePublicKey: string | null
    stripeWebhookSecret: string | null
    emailNotificaciones: string | null
    notificarWhatsApp: boolean
    notificarEmail: boolean
    createdAt: Date
    updatedAt: Date
    _count: ConfiguracionProfesorCountAggregateOutputType | null
    _avg: ConfiguracionProfesorAvgAggregateOutputType | null
    _sum: ConfiguracionProfesorSumAggregateOutputType | null
    _min: ConfiguracionProfesorMinAggregateOutputType | null
    _max: ConfiguracionProfesorMaxAggregateOutputType | null
  }

  type GetConfiguracionProfesorGroupByPayload<T extends ConfiguracionProfesorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfiguracionProfesorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfiguracionProfesorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfiguracionProfesorGroupByOutputType[P]>
            : GetScalarType<T[P], ConfiguracionProfesorGroupByOutputType[P]>
        }
      >
    >


  export type ConfiguracionProfesorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profesorId?: boolean
    nombreCurso?: boolean
    descripcionCurso?: boolean
    precioCurso?: boolean
    moneda?: boolean
    bioProfesor?: boolean
    fotoProfesorUrl?: boolean
    emailContacto?: boolean
    whatsappNumero?: boolean
    pais?: boolean
    stripeSecretKey?: boolean
    stripePublicKey?: boolean
    stripeWebhookSecret?: boolean
    emailNotificaciones?: boolean
    notificarWhatsApp?: boolean
    notificarEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configuracionProfesor"]>

  export type ConfiguracionProfesorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profesorId?: boolean
    nombreCurso?: boolean
    descripcionCurso?: boolean
    precioCurso?: boolean
    moneda?: boolean
    bioProfesor?: boolean
    fotoProfesorUrl?: boolean
    emailContacto?: boolean
    whatsappNumero?: boolean
    pais?: boolean
    stripeSecretKey?: boolean
    stripePublicKey?: boolean
    stripeWebhookSecret?: boolean
    emailNotificaciones?: boolean
    notificarWhatsApp?: boolean
    notificarEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configuracionProfesor"]>

  export type ConfiguracionProfesorSelectScalar = {
    id?: boolean
    profesorId?: boolean
    nombreCurso?: boolean
    descripcionCurso?: boolean
    precioCurso?: boolean
    moneda?: boolean
    bioProfesor?: boolean
    fotoProfesorUrl?: boolean
    emailContacto?: boolean
    whatsappNumero?: boolean
    pais?: boolean
    stripeSecretKey?: boolean
    stripePublicKey?: boolean
    stripeWebhookSecret?: boolean
    emailNotificaciones?: boolean
    notificarWhatsApp?: boolean
    notificarEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConfiguracionProfesorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
  }
  export type ConfiguracionProfesorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
  }

  export type $ConfiguracionProfesorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfiguracionProfesor"
    objects: {
      profesor: Prisma.$ProfesorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profesorId: string
      nombreCurso: string
      descripcionCurso: string | null
      precioCurso: Prisma.Decimal
      moneda: string
      bioProfesor: string | null
      fotoProfesorUrl: string | null
      emailContacto: string | null
      whatsappNumero: string | null
      pais: string | null
      stripeSecretKey: string | null
      stripePublicKey: string | null
      stripeWebhookSecret: string | null
      emailNotificaciones: string | null
      notificarWhatsApp: boolean
      notificarEmail: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configuracionProfesor"]>
    composites: {}
  }

  type ConfiguracionProfesorGetPayload<S extends boolean | null | undefined | ConfiguracionProfesorDefaultArgs> = $Result.GetResult<Prisma.$ConfiguracionProfesorPayload, S>

  type ConfiguracionProfesorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConfiguracionProfesorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfiguracionProfesorCountAggregateInputType | true
    }

  export interface ConfiguracionProfesorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfiguracionProfesor'], meta: { name: 'ConfiguracionProfesor' } }
    /**
     * Find zero or one ConfiguracionProfesor that matches the filter.
     * @param {ConfiguracionProfesorFindUniqueArgs} args - Arguments to find a ConfiguracionProfesor
     * @example
     * // Get one ConfiguracionProfesor
     * const configuracionProfesor = await prisma.configuracionProfesor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfiguracionProfesorFindUniqueArgs>(args: SelectSubset<T, ConfiguracionProfesorFindUniqueArgs<ExtArgs>>): Prisma__ConfiguracionProfesorClient<$Result.GetResult<Prisma.$ConfiguracionProfesorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConfiguracionProfesor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConfiguracionProfesorFindUniqueOrThrowArgs} args - Arguments to find a ConfiguracionProfesor
     * @example
     * // Get one ConfiguracionProfesor
     * const configuracionProfesor = await prisma.configuracionProfesor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfiguracionProfesorFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfiguracionProfesorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfiguracionProfesorClient<$Result.GetResult<Prisma.$ConfiguracionProfesorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConfiguracionProfesor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionProfesorFindFirstArgs} args - Arguments to find a ConfiguracionProfesor
     * @example
     * // Get one ConfiguracionProfesor
     * const configuracionProfesor = await prisma.configuracionProfesor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfiguracionProfesorFindFirstArgs>(args?: SelectSubset<T, ConfiguracionProfesorFindFirstArgs<ExtArgs>>): Prisma__ConfiguracionProfesorClient<$Result.GetResult<Prisma.$ConfiguracionProfesorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConfiguracionProfesor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionProfesorFindFirstOrThrowArgs} args - Arguments to find a ConfiguracionProfesor
     * @example
     * // Get one ConfiguracionProfesor
     * const configuracionProfesor = await prisma.configuracionProfesor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfiguracionProfesorFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfiguracionProfesorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfiguracionProfesorClient<$Result.GetResult<Prisma.$ConfiguracionProfesorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConfiguracionProfesors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionProfesorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfiguracionProfesors
     * const configuracionProfesors = await prisma.configuracionProfesor.findMany()
     * 
     * // Get first 10 ConfiguracionProfesors
     * const configuracionProfesors = await prisma.configuracionProfesor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configuracionProfesorWithIdOnly = await prisma.configuracionProfesor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfiguracionProfesorFindManyArgs>(args?: SelectSubset<T, ConfiguracionProfesorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfiguracionProfesorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConfiguracionProfesor.
     * @param {ConfiguracionProfesorCreateArgs} args - Arguments to create a ConfiguracionProfesor.
     * @example
     * // Create one ConfiguracionProfesor
     * const ConfiguracionProfesor = await prisma.configuracionProfesor.create({
     *   data: {
     *     // ... data to create a ConfiguracionProfesor
     *   }
     * })
     * 
     */
    create<T extends ConfiguracionProfesorCreateArgs>(args: SelectSubset<T, ConfiguracionProfesorCreateArgs<ExtArgs>>): Prisma__ConfiguracionProfesorClient<$Result.GetResult<Prisma.$ConfiguracionProfesorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConfiguracionProfesors.
     * @param {ConfiguracionProfesorCreateManyArgs} args - Arguments to create many ConfiguracionProfesors.
     * @example
     * // Create many ConfiguracionProfesors
     * const configuracionProfesor = await prisma.configuracionProfesor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfiguracionProfesorCreateManyArgs>(args?: SelectSubset<T, ConfiguracionProfesorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfiguracionProfesors and returns the data saved in the database.
     * @param {ConfiguracionProfesorCreateManyAndReturnArgs} args - Arguments to create many ConfiguracionProfesors.
     * @example
     * // Create many ConfiguracionProfesors
     * const configuracionProfesor = await prisma.configuracionProfesor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfiguracionProfesors and only return the `id`
     * const configuracionProfesorWithIdOnly = await prisma.configuracionProfesor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfiguracionProfesorCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfiguracionProfesorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfiguracionProfesorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConfiguracionProfesor.
     * @param {ConfiguracionProfesorDeleteArgs} args - Arguments to delete one ConfiguracionProfesor.
     * @example
     * // Delete one ConfiguracionProfesor
     * const ConfiguracionProfesor = await prisma.configuracionProfesor.delete({
     *   where: {
     *     // ... filter to delete one ConfiguracionProfesor
     *   }
     * })
     * 
     */
    delete<T extends ConfiguracionProfesorDeleteArgs>(args: SelectSubset<T, ConfiguracionProfesorDeleteArgs<ExtArgs>>): Prisma__ConfiguracionProfesorClient<$Result.GetResult<Prisma.$ConfiguracionProfesorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConfiguracionProfesor.
     * @param {ConfiguracionProfesorUpdateArgs} args - Arguments to update one ConfiguracionProfesor.
     * @example
     * // Update one ConfiguracionProfesor
     * const configuracionProfesor = await prisma.configuracionProfesor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfiguracionProfesorUpdateArgs>(args: SelectSubset<T, ConfiguracionProfesorUpdateArgs<ExtArgs>>): Prisma__ConfiguracionProfesorClient<$Result.GetResult<Prisma.$ConfiguracionProfesorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConfiguracionProfesors.
     * @param {ConfiguracionProfesorDeleteManyArgs} args - Arguments to filter ConfiguracionProfesors to delete.
     * @example
     * // Delete a few ConfiguracionProfesors
     * const { count } = await prisma.configuracionProfesor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfiguracionProfesorDeleteManyArgs>(args?: SelectSubset<T, ConfiguracionProfesorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfiguracionProfesors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionProfesorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfiguracionProfesors
     * const configuracionProfesor = await prisma.configuracionProfesor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfiguracionProfesorUpdateManyArgs>(args: SelectSubset<T, ConfiguracionProfesorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConfiguracionProfesor.
     * @param {ConfiguracionProfesorUpsertArgs} args - Arguments to update or create a ConfiguracionProfesor.
     * @example
     * // Update or create a ConfiguracionProfesor
     * const configuracionProfesor = await prisma.configuracionProfesor.upsert({
     *   create: {
     *     // ... data to create a ConfiguracionProfesor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfiguracionProfesor we want to update
     *   }
     * })
     */
    upsert<T extends ConfiguracionProfesorUpsertArgs>(args: SelectSubset<T, ConfiguracionProfesorUpsertArgs<ExtArgs>>): Prisma__ConfiguracionProfesorClient<$Result.GetResult<Prisma.$ConfiguracionProfesorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConfiguracionProfesors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionProfesorCountArgs} args - Arguments to filter ConfiguracionProfesors to count.
     * @example
     * // Count the number of ConfiguracionProfesors
     * const count = await prisma.configuracionProfesor.count({
     *   where: {
     *     // ... the filter for the ConfiguracionProfesors we want to count
     *   }
     * })
    **/
    count<T extends ConfiguracionProfesorCountArgs>(
      args?: Subset<T, ConfiguracionProfesorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfiguracionProfesorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfiguracionProfesor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionProfesorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfiguracionProfesorAggregateArgs>(args: Subset<T, ConfiguracionProfesorAggregateArgs>): Prisma.PrismaPromise<GetConfiguracionProfesorAggregateType<T>>

    /**
     * Group by ConfiguracionProfesor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionProfesorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfiguracionProfesorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfiguracionProfesorGroupByArgs['orderBy'] }
        : { orderBy?: ConfiguracionProfesorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfiguracionProfesorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfiguracionProfesorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfiguracionProfesor model
   */
  readonly fields: ConfiguracionProfesorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfiguracionProfesor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfiguracionProfesorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profesor<T extends ProfesorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfesorDefaultArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfiguracionProfesor model
   */ 
  interface ConfiguracionProfesorFieldRefs {
    readonly id: FieldRef<"ConfiguracionProfesor", 'String'>
    readonly profesorId: FieldRef<"ConfiguracionProfesor", 'String'>
    readonly nombreCurso: FieldRef<"ConfiguracionProfesor", 'String'>
    readonly descripcionCurso: FieldRef<"ConfiguracionProfesor", 'String'>
    readonly precioCurso: FieldRef<"ConfiguracionProfesor", 'Decimal'>
    readonly moneda: FieldRef<"ConfiguracionProfesor", 'String'>
    readonly bioProfesor: FieldRef<"ConfiguracionProfesor", 'String'>
    readonly fotoProfesorUrl: FieldRef<"ConfiguracionProfesor", 'String'>
    readonly emailContacto: FieldRef<"ConfiguracionProfesor", 'String'>
    readonly whatsappNumero: FieldRef<"ConfiguracionProfesor", 'String'>
    readonly pais: FieldRef<"ConfiguracionProfesor", 'String'>
    readonly stripeSecretKey: FieldRef<"ConfiguracionProfesor", 'String'>
    readonly stripePublicKey: FieldRef<"ConfiguracionProfesor", 'String'>
    readonly stripeWebhookSecret: FieldRef<"ConfiguracionProfesor", 'String'>
    readonly emailNotificaciones: FieldRef<"ConfiguracionProfesor", 'String'>
    readonly notificarWhatsApp: FieldRef<"ConfiguracionProfesor", 'Boolean'>
    readonly notificarEmail: FieldRef<"ConfiguracionProfesor", 'Boolean'>
    readonly createdAt: FieldRef<"ConfiguracionProfesor", 'DateTime'>
    readonly updatedAt: FieldRef<"ConfiguracionProfesor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConfiguracionProfesor findUnique
   */
  export type ConfiguracionProfesorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionProfesor
     */
    select?: ConfiguracionProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionProfesorInclude<ExtArgs> | null
    /**
     * Filter, which ConfiguracionProfesor to fetch.
     */
    where: ConfiguracionProfesorWhereUniqueInput
  }

  /**
   * ConfiguracionProfesor findUniqueOrThrow
   */
  export type ConfiguracionProfesorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionProfesor
     */
    select?: ConfiguracionProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionProfesorInclude<ExtArgs> | null
    /**
     * Filter, which ConfiguracionProfesor to fetch.
     */
    where: ConfiguracionProfesorWhereUniqueInput
  }

  /**
   * ConfiguracionProfesor findFirst
   */
  export type ConfiguracionProfesorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionProfesor
     */
    select?: ConfiguracionProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionProfesorInclude<ExtArgs> | null
    /**
     * Filter, which ConfiguracionProfesor to fetch.
     */
    where?: ConfiguracionProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracionProfesors to fetch.
     */
    orderBy?: ConfiguracionProfesorOrderByWithRelationInput | ConfiguracionProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfiguracionProfesors.
     */
    cursor?: ConfiguracionProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracionProfesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracionProfesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfiguracionProfesors.
     */
    distinct?: ConfiguracionProfesorScalarFieldEnum | ConfiguracionProfesorScalarFieldEnum[]
  }

  /**
   * ConfiguracionProfesor findFirstOrThrow
   */
  export type ConfiguracionProfesorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionProfesor
     */
    select?: ConfiguracionProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionProfesorInclude<ExtArgs> | null
    /**
     * Filter, which ConfiguracionProfesor to fetch.
     */
    where?: ConfiguracionProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracionProfesors to fetch.
     */
    orderBy?: ConfiguracionProfesorOrderByWithRelationInput | ConfiguracionProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfiguracionProfesors.
     */
    cursor?: ConfiguracionProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracionProfesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracionProfesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfiguracionProfesors.
     */
    distinct?: ConfiguracionProfesorScalarFieldEnum | ConfiguracionProfesorScalarFieldEnum[]
  }

  /**
   * ConfiguracionProfesor findMany
   */
  export type ConfiguracionProfesorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionProfesor
     */
    select?: ConfiguracionProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionProfesorInclude<ExtArgs> | null
    /**
     * Filter, which ConfiguracionProfesors to fetch.
     */
    where?: ConfiguracionProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracionProfesors to fetch.
     */
    orderBy?: ConfiguracionProfesorOrderByWithRelationInput | ConfiguracionProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfiguracionProfesors.
     */
    cursor?: ConfiguracionProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracionProfesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracionProfesors.
     */
    skip?: number
    distinct?: ConfiguracionProfesorScalarFieldEnum | ConfiguracionProfesorScalarFieldEnum[]
  }

  /**
   * ConfiguracionProfesor create
   */
  export type ConfiguracionProfesorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionProfesor
     */
    select?: ConfiguracionProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionProfesorInclude<ExtArgs> | null
    /**
     * The data needed to create a ConfiguracionProfesor.
     */
    data: XOR<ConfiguracionProfesorCreateInput, ConfiguracionProfesorUncheckedCreateInput>
  }

  /**
   * ConfiguracionProfesor createMany
   */
  export type ConfiguracionProfesorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfiguracionProfesors.
     */
    data: ConfiguracionProfesorCreateManyInput | ConfiguracionProfesorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfiguracionProfesor createManyAndReturn
   */
  export type ConfiguracionProfesorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionProfesor
     */
    select?: ConfiguracionProfesorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConfiguracionProfesors.
     */
    data: ConfiguracionProfesorCreateManyInput | ConfiguracionProfesorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionProfesorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConfiguracionProfesor update
   */
  export type ConfiguracionProfesorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionProfesor
     */
    select?: ConfiguracionProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionProfesorInclude<ExtArgs> | null
    /**
     * The data needed to update a ConfiguracionProfesor.
     */
    data: XOR<ConfiguracionProfesorUpdateInput, ConfiguracionProfesorUncheckedUpdateInput>
    /**
     * Choose, which ConfiguracionProfesor to update.
     */
    where: ConfiguracionProfesorWhereUniqueInput
  }

  /**
   * ConfiguracionProfesor updateMany
   */
  export type ConfiguracionProfesorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfiguracionProfesors.
     */
    data: XOR<ConfiguracionProfesorUpdateManyMutationInput, ConfiguracionProfesorUncheckedUpdateManyInput>
    /**
     * Filter which ConfiguracionProfesors to update
     */
    where?: ConfiguracionProfesorWhereInput
  }

  /**
   * ConfiguracionProfesor upsert
   */
  export type ConfiguracionProfesorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionProfesor
     */
    select?: ConfiguracionProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionProfesorInclude<ExtArgs> | null
    /**
     * The filter to search for the ConfiguracionProfesor to update in case it exists.
     */
    where: ConfiguracionProfesorWhereUniqueInput
    /**
     * In case the ConfiguracionProfesor found by the `where` argument doesn't exist, create a new ConfiguracionProfesor with this data.
     */
    create: XOR<ConfiguracionProfesorCreateInput, ConfiguracionProfesorUncheckedCreateInput>
    /**
     * In case the ConfiguracionProfesor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfiguracionProfesorUpdateInput, ConfiguracionProfesorUncheckedUpdateInput>
  }

  /**
   * ConfiguracionProfesor delete
   */
  export type ConfiguracionProfesorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionProfesor
     */
    select?: ConfiguracionProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionProfesorInclude<ExtArgs> | null
    /**
     * Filter which ConfiguracionProfesor to delete.
     */
    where: ConfiguracionProfesorWhereUniqueInput
  }

  /**
   * ConfiguracionProfesor deleteMany
   */
  export type ConfiguracionProfesorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfiguracionProfesors to delete
     */
    where?: ConfiguracionProfesorWhereInput
  }

  /**
   * ConfiguracionProfesor without action
   */
  export type ConfiguracionProfesorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionProfesor
     */
    select?: ConfiguracionProfesorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionProfesorInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    nombre: 'nombre',
    avatarUrl: 'avatarUrl',
    rol: 'rol',
    estado: 'estado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EstudianteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    estadoAprobacion: 'estadoAprobacion',
    estadoPago: 'estadoPago',
    fechaAprobacion: 'fechaAprobacion',
    fechaPago: 'fechaPago',
    montoPagado: 'montoPagado',
    metodoPago: 'metodoPago',
    referenciaTransaccion: 'referenciaTransaccion',
    telefono: 'telefono',
    pais: 'pais',
    experiencia: 'experiencia',
    interes: 'interes',
    fechaInscripcion: 'fechaInscripcion'
  };

  export type EstudianteScalarFieldEnum = (typeof EstudianteScalarFieldEnum)[keyof typeof EstudianteScalarFieldEnum]


  export const ProfesorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    permisos: 'permisos',
    ultimoLogin: 'ultimoLogin'
  };

  export type ProfesorScalarFieldEnum = (typeof ProfesorScalarFieldEnum)[keyof typeof ProfesorScalarFieldEnum]


  export const SolicitudAccesoScalarFieldEnum: {
    id: 'id',
    estudianteId: 'estudianteId',
    nombre: 'nombre',
    email: 'email',
    telefono: 'telefono',
    pais: 'pais',
    experiencia: 'experiencia',
    interes: 'interes',
    estado: 'estado',
    fechaSolicitud: 'fechaSolicitud',
    fechaRevision: 'fechaRevision',
    motivoRechazo: 'motivoRechazo',
    createdAt: 'createdAt'
  };

  export type SolicitudAccesoScalarFieldEnum = (typeof SolicitudAccesoScalarFieldEnum)[keyof typeof SolicitudAccesoScalarFieldEnum]


  export const ModuloScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    descripcion: 'descripcion',
    orden: 'orden',
    moduloPrevioId: 'moduloPrevioId',
    contenido: 'contenido',
    estado: 'estado',
    duracion: 'duracion',
    objetivos: 'objetivos',
    ejercicio: 'ejercicio',
    recursos: 'recursos',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModuloScalarFieldEnum = (typeof ModuloScalarFieldEnum)[keyof typeof ModuloScalarFieldEnum]


  export const ProgresoEstudianteScalarFieldEnum: {
    id: 'id',
    estudianteId: 'estudianteId',
    moduloId: 'moduloId',
    completudPorcentaje: 'completudPorcentaje',
    fechaCompletado: 'fechaCompletado',
    ultimaActividad: 'ultimaActividad',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgresoEstudianteScalarFieldEnum = (typeof ProgresoEstudianteScalarFieldEnum)[keyof typeof ProgresoEstudianteScalarFieldEnum]


  export const PagoScalarFieldEnum: {
    id: 'id',
    estudianteId: 'estudianteId',
    monto: 'monto',
    moneda: 'moneda',
    proveedor: 'proveedor',
    referenciaExterna: 'referenciaExterna',
    estado: 'estado',
    fechaPago: 'fechaPago',
    createdAt: 'createdAt'
  };

  export type PagoScalarFieldEnum = (typeof PagoScalarFieldEnum)[keyof typeof PagoScalarFieldEnum]


  export const ConfiguracionProfesorScalarFieldEnum: {
    id: 'id',
    profesorId: 'profesorId',
    nombreCurso: 'nombreCurso',
    descripcionCurso: 'descripcionCurso',
    precioCurso: 'precioCurso',
    moneda: 'moneda',
    bioProfesor: 'bioProfesor',
    fotoProfesorUrl: 'fotoProfesorUrl',
    emailContacto: 'emailContacto',
    whatsappNumero: 'whatsappNumero',
    pais: 'pais',
    stripeSecretKey: 'stripeSecretKey',
    stripePublicKey: 'stripePublicKey',
    stripeWebhookSecret: 'stripeWebhookSecret',
    emailNotificaciones: 'emailNotificaciones',
    notificarWhatsApp: 'notificarWhatsApp',
    notificarEmail: 'notificarEmail',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConfiguracionProfesorScalarFieldEnum = (typeof ConfiguracionProfesorScalarFieldEnum)[keyof typeof ConfiguracionProfesorScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserEstado'
   */
  export type EnumUserEstadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserEstado'>
    


  /**
   * Reference to a field of type 'UserEstado[]'
   */
  export type ListEnumUserEstadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserEstado[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'EstadoAprobacion'
   */
  export type EnumEstadoAprobacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoAprobacion'>
    


  /**
   * Reference to a field of type 'EstadoAprobacion[]'
   */
  export type ListEnumEstadoAprobacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoAprobacion[]'>
    


  /**
   * Reference to a field of type 'EstadoPago'
   */
  export type EnumEstadoPagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoPago'>
    


  /**
   * Reference to a field of type 'EstadoPago[]'
   */
  export type ListEnumEstadoPagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoPago[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'EstadoSolicitud'
   */
  export type EnumEstadoSolicitudFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoSolicitud'>
    


  /**
   * Reference to a field of type 'EstadoSolicitud[]'
   */
  export type ListEnumEstadoSolicitudFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoSolicitud[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'EstadoModulo'
   */
  export type EnumEstadoModuloFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoModulo'>
    


  /**
   * Reference to a field of type 'EstadoModulo[]'
   */
  export type ListEnumEstadoModuloFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoModulo[]'>
    


  /**
   * Reference to a field of type 'EstadoPagoTransaccion'
   */
  export type EnumEstadoPagoTransaccionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoPagoTransaccion'>
    


  /**
   * Reference to a field of type 'EstadoPagoTransaccion[]'
   */
  export type ListEnumEstadoPagoTransaccionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoPagoTransaccion[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    nombre?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    rol?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    estado?: EnumUserEstadoFilter<"User"> | $Enums.UserEstado
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    estudiante?: XOR<EstudianteNullableRelationFilter, EstudianteWhereInput> | null
    profesor?: XOR<ProfesorNullableRelationFilter, ProfesorWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    nombre?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    rol?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estudiante?: EstudianteOrderByWithRelationInput
    profesor?: ProfesorOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    nombre?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    rol?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    estado?: EnumUserEstadoFilter<"User"> | $Enums.UserEstado
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    estudiante?: XOR<EstudianteNullableRelationFilter, EstudianteWhereInput> | null
    profesor?: XOR<ProfesorNullableRelationFilter, ProfesorWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    nombre?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    rol?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    nombre?: StringWithAggregatesFilter<"User"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    rol?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    estado?: EnumUserEstadoWithAggregatesFilter<"User"> | $Enums.UserEstado
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type EstudianteWhereInput = {
    AND?: EstudianteWhereInput | EstudianteWhereInput[]
    OR?: EstudianteWhereInput[]
    NOT?: EstudianteWhereInput | EstudianteWhereInput[]
    id?: StringFilter<"Estudiante"> | string
    userId?: StringFilter<"Estudiante"> | string
    estadoAprobacion?: EnumEstadoAprobacionFilter<"Estudiante"> | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoFilter<"Estudiante"> | $Enums.EstadoPago
    fechaAprobacion?: DateTimeNullableFilter<"Estudiante"> | Date | string | null
    fechaPago?: DateTimeNullableFilter<"Estudiante"> | Date | string | null
    montoPagado?: DecimalNullableFilter<"Estudiante"> | Decimal | DecimalJsLike | number | string | null
    metodoPago?: StringNullableFilter<"Estudiante"> | string | null
    referenciaTransaccion?: StringNullableFilter<"Estudiante"> | string | null
    telefono?: StringNullableFilter<"Estudiante"> | string | null
    pais?: StringNullableFilter<"Estudiante"> | string | null
    experiencia?: StringNullableFilter<"Estudiante"> | string | null
    interes?: StringNullableFilter<"Estudiante"> | string | null
    fechaInscripcion?: DateTimeNullableFilter<"Estudiante"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    progreso?: ProgresoEstudianteListRelationFilter
    pagos?: PagoListRelationFilter
    solicitud?: XOR<SolicitudAccesoNullableRelationFilter, SolicitudAccesoWhereInput> | null
  }

  export type EstudianteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    estadoAprobacion?: SortOrder
    estadoPago?: SortOrder
    fechaAprobacion?: SortOrderInput | SortOrder
    fechaPago?: SortOrderInput | SortOrder
    montoPagado?: SortOrderInput | SortOrder
    metodoPago?: SortOrderInput | SortOrder
    referenciaTransaccion?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    pais?: SortOrderInput | SortOrder
    experiencia?: SortOrderInput | SortOrder
    interes?: SortOrderInput | SortOrder
    fechaInscripcion?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    progreso?: ProgresoEstudianteOrderByRelationAggregateInput
    pagos?: PagoOrderByRelationAggregateInput
    solicitud?: SolicitudAccesoOrderByWithRelationInput
  }

  export type EstudianteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    referenciaTransaccion?: string
    AND?: EstudianteWhereInput | EstudianteWhereInput[]
    OR?: EstudianteWhereInput[]
    NOT?: EstudianteWhereInput | EstudianteWhereInput[]
    estadoAprobacion?: EnumEstadoAprobacionFilter<"Estudiante"> | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoFilter<"Estudiante"> | $Enums.EstadoPago
    fechaAprobacion?: DateTimeNullableFilter<"Estudiante"> | Date | string | null
    fechaPago?: DateTimeNullableFilter<"Estudiante"> | Date | string | null
    montoPagado?: DecimalNullableFilter<"Estudiante"> | Decimal | DecimalJsLike | number | string | null
    metodoPago?: StringNullableFilter<"Estudiante"> | string | null
    telefono?: StringNullableFilter<"Estudiante"> | string | null
    pais?: StringNullableFilter<"Estudiante"> | string | null
    experiencia?: StringNullableFilter<"Estudiante"> | string | null
    interes?: StringNullableFilter<"Estudiante"> | string | null
    fechaInscripcion?: DateTimeNullableFilter<"Estudiante"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    progreso?: ProgresoEstudianteListRelationFilter
    pagos?: PagoListRelationFilter
    solicitud?: XOR<SolicitudAccesoNullableRelationFilter, SolicitudAccesoWhereInput> | null
  }, "id" | "userId" | "referenciaTransaccion">

  export type EstudianteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    estadoAprobacion?: SortOrder
    estadoPago?: SortOrder
    fechaAprobacion?: SortOrderInput | SortOrder
    fechaPago?: SortOrderInput | SortOrder
    montoPagado?: SortOrderInput | SortOrder
    metodoPago?: SortOrderInput | SortOrder
    referenciaTransaccion?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    pais?: SortOrderInput | SortOrder
    experiencia?: SortOrderInput | SortOrder
    interes?: SortOrderInput | SortOrder
    fechaInscripcion?: SortOrderInput | SortOrder
    _count?: EstudianteCountOrderByAggregateInput
    _avg?: EstudianteAvgOrderByAggregateInput
    _max?: EstudianteMaxOrderByAggregateInput
    _min?: EstudianteMinOrderByAggregateInput
    _sum?: EstudianteSumOrderByAggregateInput
  }

  export type EstudianteScalarWhereWithAggregatesInput = {
    AND?: EstudianteScalarWhereWithAggregatesInput | EstudianteScalarWhereWithAggregatesInput[]
    OR?: EstudianteScalarWhereWithAggregatesInput[]
    NOT?: EstudianteScalarWhereWithAggregatesInput | EstudianteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Estudiante"> | string
    userId?: StringWithAggregatesFilter<"Estudiante"> | string
    estadoAprobacion?: EnumEstadoAprobacionWithAggregatesFilter<"Estudiante"> | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoWithAggregatesFilter<"Estudiante"> | $Enums.EstadoPago
    fechaAprobacion?: DateTimeNullableWithAggregatesFilter<"Estudiante"> | Date | string | null
    fechaPago?: DateTimeNullableWithAggregatesFilter<"Estudiante"> | Date | string | null
    montoPagado?: DecimalNullableWithAggregatesFilter<"Estudiante"> | Decimal | DecimalJsLike | number | string | null
    metodoPago?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    referenciaTransaccion?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    pais?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    experiencia?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    interes?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    fechaInscripcion?: DateTimeNullableWithAggregatesFilter<"Estudiante"> | Date | string | null
  }

  export type ProfesorWhereInput = {
    AND?: ProfesorWhereInput | ProfesorWhereInput[]
    OR?: ProfesorWhereInput[]
    NOT?: ProfesorWhereInput | ProfesorWhereInput[]
    id?: StringFilter<"Profesor"> | string
    userId?: StringFilter<"Profesor"> | string
    permisos?: StringNullableListFilter<"Profesor">
    ultimoLogin?: DateTimeNullableFilter<"Profesor"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    configuracion?: XOR<ConfiguracionProfesorNullableRelationFilter, ConfiguracionProfesorWhereInput> | null
  }

  export type ProfesorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    permisos?: SortOrder
    ultimoLogin?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    configuracion?: ConfiguracionProfesorOrderByWithRelationInput
  }

  export type ProfesorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfesorWhereInput | ProfesorWhereInput[]
    OR?: ProfesorWhereInput[]
    NOT?: ProfesorWhereInput | ProfesorWhereInput[]
    permisos?: StringNullableListFilter<"Profesor">
    ultimoLogin?: DateTimeNullableFilter<"Profesor"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    configuracion?: XOR<ConfiguracionProfesorNullableRelationFilter, ConfiguracionProfesorWhereInput> | null
  }, "id" | "userId">

  export type ProfesorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    permisos?: SortOrder
    ultimoLogin?: SortOrderInput | SortOrder
    _count?: ProfesorCountOrderByAggregateInput
    _max?: ProfesorMaxOrderByAggregateInput
    _min?: ProfesorMinOrderByAggregateInput
  }

  export type ProfesorScalarWhereWithAggregatesInput = {
    AND?: ProfesorScalarWhereWithAggregatesInput | ProfesorScalarWhereWithAggregatesInput[]
    OR?: ProfesorScalarWhereWithAggregatesInput[]
    NOT?: ProfesorScalarWhereWithAggregatesInput | ProfesorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profesor"> | string
    userId?: StringWithAggregatesFilter<"Profesor"> | string
    permisos?: StringNullableListFilter<"Profesor">
    ultimoLogin?: DateTimeNullableWithAggregatesFilter<"Profesor"> | Date | string | null
  }

  export type SolicitudAccesoWhereInput = {
    AND?: SolicitudAccesoWhereInput | SolicitudAccesoWhereInput[]
    OR?: SolicitudAccesoWhereInput[]
    NOT?: SolicitudAccesoWhereInput | SolicitudAccesoWhereInput[]
    id?: StringFilter<"SolicitudAcceso"> | string
    estudianteId?: StringNullableFilter<"SolicitudAcceso"> | string | null
    nombre?: StringFilter<"SolicitudAcceso"> | string
    email?: StringFilter<"SolicitudAcceso"> | string
    telefono?: StringNullableFilter<"SolicitudAcceso"> | string | null
    pais?: StringNullableFilter<"SolicitudAcceso"> | string | null
    experiencia?: StringNullableFilter<"SolicitudAcceso"> | string | null
    interes?: StringNullableFilter<"SolicitudAcceso"> | string | null
    estado?: EnumEstadoSolicitudFilter<"SolicitudAcceso"> | $Enums.EstadoSolicitud
    fechaSolicitud?: DateTimeFilter<"SolicitudAcceso"> | Date | string
    fechaRevision?: DateTimeNullableFilter<"SolicitudAcceso"> | Date | string | null
    motivoRechazo?: StringNullableFilter<"SolicitudAcceso"> | string | null
    createdAt?: DateTimeFilter<"SolicitudAcceso"> | Date | string
    estudiante?: XOR<EstudianteNullableRelationFilter, EstudianteWhereInput> | null
  }

  export type SolicitudAccesoOrderByWithRelationInput = {
    id?: SortOrder
    estudianteId?: SortOrderInput | SortOrder
    nombre?: SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    pais?: SortOrderInput | SortOrder
    experiencia?: SortOrderInput | SortOrder
    interes?: SortOrderInput | SortOrder
    estado?: SortOrder
    fechaSolicitud?: SortOrder
    fechaRevision?: SortOrderInput | SortOrder
    motivoRechazo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    estudiante?: EstudianteOrderByWithRelationInput
  }

  export type SolicitudAccesoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    estudianteId?: string
    AND?: SolicitudAccesoWhereInput | SolicitudAccesoWhereInput[]
    OR?: SolicitudAccesoWhereInput[]
    NOT?: SolicitudAccesoWhereInput | SolicitudAccesoWhereInput[]
    nombre?: StringFilter<"SolicitudAcceso"> | string
    email?: StringFilter<"SolicitudAcceso"> | string
    telefono?: StringNullableFilter<"SolicitudAcceso"> | string | null
    pais?: StringNullableFilter<"SolicitudAcceso"> | string | null
    experiencia?: StringNullableFilter<"SolicitudAcceso"> | string | null
    interes?: StringNullableFilter<"SolicitudAcceso"> | string | null
    estado?: EnumEstadoSolicitudFilter<"SolicitudAcceso"> | $Enums.EstadoSolicitud
    fechaSolicitud?: DateTimeFilter<"SolicitudAcceso"> | Date | string
    fechaRevision?: DateTimeNullableFilter<"SolicitudAcceso"> | Date | string | null
    motivoRechazo?: StringNullableFilter<"SolicitudAcceso"> | string | null
    createdAt?: DateTimeFilter<"SolicitudAcceso"> | Date | string
    estudiante?: XOR<EstudianteNullableRelationFilter, EstudianteWhereInput> | null
  }, "id" | "estudianteId">

  export type SolicitudAccesoOrderByWithAggregationInput = {
    id?: SortOrder
    estudianteId?: SortOrderInput | SortOrder
    nombre?: SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    pais?: SortOrderInput | SortOrder
    experiencia?: SortOrderInput | SortOrder
    interes?: SortOrderInput | SortOrder
    estado?: SortOrder
    fechaSolicitud?: SortOrder
    fechaRevision?: SortOrderInput | SortOrder
    motivoRechazo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SolicitudAccesoCountOrderByAggregateInput
    _max?: SolicitudAccesoMaxOrderByAggregateInput
    _min?: SolicitudAccesoMinOrderByAggregateInput
  }

  export type SolicitudAccesoScalarWhereWithAggregatesInput = {
    AND?: SolicitudAccesoScalarWhereWithAggregatesInput | SolicitudAccesoScalarWhereWithAggregatesInput[]
    OR?: SolicitudAccesoScalarWhereWithAggregatesInput[]
    NOT?: SolicitudAccesoScalarWhereWithAggregatesInput | SolicitudAccesoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SolicitudAcceso"> | string
    estudianteId?: StringNullableWithAggregatesFilter<"SolicitudAcceso"> | string | null
    nombre?: StringWithAggregatesFilter<"SolicitudAcceso"> | string
    email?: StringWithAggregatesFilter<"SolicitudAcceso"> | string
    telefono?: StringNullableWithAggregatesFilter<"SolicitudAcceso"> | string | null
    pais?: StringNullableWithAggregatesFilter<"SolicitudAcceso"> | string | null
    experiencia?: StringNullableWithAggregatesFilter<"SolicitudAcceso"> | string | null
    interes?: StringNullableWithAggregatesFilter<"SolicitudAcceso"> | string | null
    estado?: EnumEstadoSolicitudWithAggregatesFilter<"SolicitudAcceso"> | $Enums.EstadoSolicitud
    fechaSolicitud?: DateTimeWithAggregatesFilter<"SolicitudAcceso"> | Date | string
    fechaRevision?: DateTimeNullableWithAggregatesFilter<"SolicitudAcceso"> | Date | string | null
    motivoRechazo?: StringNullableWithAggregatesFilter<"SolicitudAcceso"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SolicitudAcceso"> | Date | string
  }

  export type ModuloWhereInput = {
    AND?: ModuloWhereInput | ModuloWhereInput[]
    OR?: ModuloWhereInput[]
    NOT?: ModuloWhereInput | ModuloWhereInput[]
    id?: StringFilter<"Modulo"> | string
    titulo?: StringFilter<"Modulo"> | string
    descripcion?: StringNullableFilter<"Modulo"> | string | null
    orden?: IntFilter<"Modulo"> | number
    moduloPrevioId?: StringNullableFilter<"Modulo"> | string | null
    contenido?: JsonNullableFilter<"Modulo">
    estado?: EnumEstadoModuloFilter<"Modulo"> | $Enums.EstadoModulo
    duracion?: StringNullableFilter<"Modulo"> | string | null
    objetivos?: StringNullableListFilter<"Modulo">
    ejercicio?: JsonNullableFilter<"Modulo">
    recursos?: JsonNullableFilter<"Modulo">
    createdAt?: DateTimeFilter<"Modulo"> | Date | string
    updatedAt?: DateTimeFilter<"Modulo"> | Date | string
    progreso?: ProgresoEstudianteListRelationFilter
  }

  export type ModuloOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    orden?: SortOrder
    moduloPrevioId?: SortOrderInput | SortOrder
    contenido?: SortOrderInput | SortOrder
    estado?: SortOrder
    duracion?: SortOrderInput | SortOrder
    objetivos?: SortOrder
    ejercicio?: SortOrderInput | SortOrder
    recursos?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    progreso?: ProgresoEstudianteOrderByRelationAggregateInput
  }

  export type ModuloWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModuloWhereInput | ModuloWhereInput[]
    OR?: ModuloWhereInput[]
    NOT?: ModuloWhereInput | ModuloWhereInput[]
    titulo?: StringFilter<"Modulo"> | string
    descripcion?: StringNullableFilter<"Modulo"> | string | null
    orden?: IntFilter<"Modulo"> | number
    moduloPrevioId?: StringNullableFilter<"Modulo"> | string | null
    contenido?: JsonNullableFilter<"Modulo">
    estado?: EnumEstadoModuloFilter<"Modulo"> | $Enums.EstadoModulo
    duracion?: StringNullableFilter<"Modulo"> | string | null
    objetivos?: StringNullableListFilter<"Modulo">
    ejercicio?: JsonNullableFilter<"Modulo">
    recursos?: JsonNullableFilter<"Modulo">
    createdAt?: DateTimeFilter<"Modulo"> | Date | string
    updatedAt?: DateTimeFilter<"Modulo"> | Date | string
    progreso?: ProgresoEstudianteListRelationFilter
  }, "id">

  export type ModuloOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    orden?: SortOrder
    moduloPrevioId?: SortOrderInput | SortOrder
    contenido?: SortOrderInput | SortOrder
    estado?: SortOrder
    duracion?: SortOrderInput | SortOrder
    objetivos?: SortOrder
    ejercicio?: SortOrderInput | SortOrder
    recursos?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModuloCountOrderByAggregateInput
    _avg?: ModuloAvgOrderByAggregateInput
    _max?: ModuloMaxOrderByAggregateInput
    _min?: ModuloMinOrderByAggregateInput
    _sum?: ModuloSumOrderByAggregateInput
  }

  export type ModuloScalarWhereWithAggregatesInput = {
    AND?: ModuloScalarWhereWithAggregatesInput | ModuloScalarWhereWithAggregatesInput[]
    OR?: ModuloScalarWhereWithAggregatesInput[]
    NOT?: ModuloScalarWhereWithAggregatesInput | ModuloScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Modulo"> | string
    titulo?: StringWithAggregatesFilter<"Modulo"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Modulo"> | string | null
    orden?: IntWithAggregatesFilter<"Modulo"> | number
    moduloPrevioId?: StringNullableWithAggregatesFilter<"Modulo"> | string | null
    contenido?: JsonNullableWithAggregatesFilter<"Modulo">
    estado?: EnumEstadoModuloWithAggregatesFilter<"Modulo"> | $Enums.EstadoModulo
    duracion?: StringNullableWithAggregatesFilter<"Modulo"> | string | null
    objetivos?: StringNullableListFilter<"Modulo">
    ejercicio?: JsonNullableWithAggregatesFilter<"Modulo">
    recursos?: JsonNullableWithAggregatesFilter<"Modulo">
    createdAt?: DateTimeWithAggregatesFilter<"Modulo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Modulo"> | Date | string
  }

  export type ProgresoEstudianteWhereInput = {
    AND?: ProgresoEstudianteWhereInput | ProgresoEstudianteWhereInput[]
    OR?: ProgresoEstudianteWhereInput[]
    NOT?: ProgresoEstudianteWhereInput | ProgresoEstudianteWhereInput[]
    id?: StringFilter<"ProgresoEstudiante"> | string
    estudianteId?: StringFilter<"ProgresoEstudiante"> | string
    moduloId?: StringFilter<"ProgresoEstudiante"> | string
    completudPorcentaje?: IntFilter<"ProgresoEstudiante"> | number
    fechaCompletado?: DateTimeNullableFilter<"ProgresoEstudiante"> | Date | string | null
    ultimaActividad?: DateTimeNullableFilter<"ProgresoEstudiante"> | Date | string | null
    createdAt?: DateTimeFilter<"ProgresoEstudiante"> | Date | string
    updatedAt?: DateTimeFilter<"ProgresoEstudiante"> | Date | string
    estudiante?: XOR<EstudianteRelationFilter, EstudianteWhereInput>
    modulo?: XOR<ModuloRelationFilter, ModuloWhereInput>
  }

  export type ProgresoEstudianteOrderByWithRelationInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    moduloId?: SortOrder
    completudPorcentaje?: SortOrder
    fechaCompletado?: SortOrderInput | SortOrder
    ultimaActividad?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estudiante?: EstudianteOrderByWithRelationInput
    modulo?: ModuloOrderByWithRelationInput
  }

  export type ProgresoEstudianteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    estudianteId_moduloId?: ProgresoEstudianteEstudianteIdModuloIdCompoundUniqueInput
    AND?: ProgresoEstudianteWhereInput | ProgresoEstudianteWhereInput[]
    OR?: ProgresoEstudianteWhereInput[]
    NOT?: ProgresoEstudianteWhereInput | ProgresoEstudianteWhereInput[]
    estudianteId?: StringFilter<"ProgresoEstudiante"> | string
    moduloId?: StringFilter<"ProgresoEstudiante"> | string
    completudPorcentaje?: IntFilter<"ProgresoEstudiante"> | number
    fechaCompletado?: DateTimeNullableFilter<"ProgresoEstudiante"> | Date | string | null
    ultimaActividad?: DateTimeNullableFilter<"ProgresoEstudiante"> | Date | string | null
    createdAt?: DateTimeFilter<"ProgresoEstudiante"> | Date | string
    updatedAt?: DateTimeFilter<"ProgresoEstudiante"> | Date | string
    estudiante?: XOR<EstudianteRelationFilter, EstudianteWhereInput>
    modulo?: XOR<ModuloRelationFilter, ModuloWhereInput>
  }, "id" | "estudianteId_moduloId">

  export type ProgresoEstudianteOrderByWithAggregationInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    moduloId?: SortOrder
    completudPorcentaje?: SortOrder
    fechaCompletado?: SortOrderInput | SortOrder
    ultimaActividad?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProgresoEstudianteCountOrderByAggregateInput
    _avg?: ProgresoEstudianteAvgOrderByAggregateInput
    _max?: ProgresoEstudianteMaxOrderByAggregateInput
    _min?: ProgresoEstudianteMinOrderByAggregateInput
    _sum?: ProgresoEstudianteSumOrderByAggregateInput
  }

  export type ProgresoEstudianteScalarWhereWithAggregatesInput = {
    AND?: ProgresoEstudianteScalarWhereWithAggregatesInput | ProgresoEstudianteScalarWhereWithAggregatesInput[]
    OR?: ProgresoEstudianteScalarWhereWithAggregatesInput[]
    NOT?: ProgresoEstudianteScalarWhereWithAggregatesInput | ProgresoEstudianteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgresoEstudiante"> | string
    estudianteId?: StringWithAggregatesFilter<"ProgresoEstudiante"> | string
    moduloId?: StringWithAggregatesFilter<"ProgresoEstudiante"> | string
    completudPorcentaje?: IntWithAggregatesFilter<"ProgresoEstudiante"> | number
    fechaCompletado?: DateTimeNullableWithAggregatesFilter<"ProgresoEstudiante"> | Date | string | null
    ultimaActividad?: DateTimeNullableWithAggregatesFilter<"ProgresoEstudiante"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProgresoEstudiante"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProgresoEstudiante"> | Date | string
  }

  export type PagoWhereInput = {
    AND?: PagoWhereInput | PagoWhereInput[]
    OR?: PagoWhereInput[]
    NOT?: PagoWhereInput | PagoWhereInput[]
    id?: StringFilter<"Pago"> | string
    estudianteId?: StringFilter<"Pago"> | string
    monto?: DecimalFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"Pago"> | string
    proveedor?: StringFilter<"Pago"> | string
    referenciaExterna?: StringFilter<"Pago"> | string
    estado?: EnumEstadoPagoTransaccionFilter<"Pago"> | $Enums.EstadoPagoTransaccion
    fechaPago?: DateTimeNullableFilter<"Pago"> | Date | string | null
    createdAt?: DateTimeFilter<"Pago"> | Date | string
    estudiante?: XOR<EstudianteRelationFilter, EstudianteWhereInput>
  }

  export type PagoOrderByWithRelationInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    proveedor?: SortOrder
    referenciaExterna?: SortOrder
    estado?: SortOrder
    fechaPago?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    estudiante?: EstudianteOrderByWithRelationInput
  }

  export type PagoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PagoWhereInput | PagoWhereInput[]
    OR?: PagoWhereInput[]
    NOT?: PagoWhereInput | PagoWhereInput[]
    estudianteId?: StringFilter<"Pago"> | string
    monto?: DecimalFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"Pago"> | string
    proveedor?: StringFilter<"Pago"> | string
    referenciaExterna?: StringFilter<"Pago"> | string
    estado?: EnumEstadoPagoTransaccionFilter<"Pago"> | $Enums.EstadoPagoTransaccion
    fechaPago?: DateTimeNullableFilter<"Pago"> | Date | string | null
    createdAt?: DateTimeFilter<"Pago"> | Date | string
    estudiante?: XOR<EstudianteRelationFilter, EstudianteWhereInput>
  }, "id">

  export type PagoOrderByWithAggregationInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    proveedor?: SortOrder
    referenciaExterna?: SortOrder
    estado?: SortOrder
    fechaPago?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PagoCountOrderByAggregateInput
    _avg?: PagoAvgOrderByAggregateInput
    _max?: PagoMaxOrderByAggregateInput
    _min?: PagoMinOrderByAggregateInput
    _sum?: PagoSumOrderByAggregateInput
  }

  export type PagoScalarWhereWithAggregatesInput = {
    AND?: PagoScalarWhereWithAggregatesInput | PagoScalarWhereWithAggregatesInput[]
    OR?: PagoScalarWhereWithAggregatesInput[]
    NOT?: PagoScalarWhereWithAggregatesInput | PagoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pago"> | string
    estudianteId?: StringWithAggregatesFilter<"Pago"> | string
    monto?: DecimalWithAggregatesFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    moneda?: StringWithAggregatesFilter<"Pago"> | string
    proveedor?: StringWithAggregatesFilter<"Pago"> | string
    referenciaExterna?: StringWithAggregatesFilter<"Pago"> | string
    estado?: EnumEstadoPagoTransaccionWithAggregatesFilter<"Pago"> | $Enums.EstadoPagoTransaccion
    fechaPago?: DateTimeNullableWithAggregatesFilter<"Pago"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Pago"> | Date | string
  }

  export type ConfiguracionProfesorWhereInput = {
    AND?: ConfiguracionProfesorWhereInput | ConfiguracionProfesorWhereInput[]
    OR?: ConfiguracionProfesorWhereInput[]
    NOT?: ConfiguracionProfesorWhereInput | ConfiguracionProfesorWhereInput[]
    id?: StringFilter<"ConfiguracionProfesor"> | string
    profesorId?: StringFilter<"ConfiguracionProfesor"> | string
    nombreCurso?: StringFilter<"ConfiguracionProfesor"> | string
    descripcionCurso?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    precioCurso?: DecimalFilter<"ConfiguracionProfesor"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"ConfiguracionProfesor"> | string
    bioProfesor?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    fotoProfesorUrl?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    emailContacto?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    whatsappNumero?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    pais?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    stripeSecretKey?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    stripePublicKey?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    stripeWebhookSecret?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    emailNotificaciones?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    notificarWhatsApp?: BoolFilter<"ConfiguracionProfesor"> | boolean
    notificarEmail?: BoolFilter<"ConfiguracionProfesor"> | boolean
    createdAt?: DateTimeFilter<"ConfiguracionProfesor"> | Date | string
    updatedAt?: DateTimeFilter<"ConfiguracionProfesor"> | Date | string
    profesor?: XOR<ProfesorRelationFilter, ProfesorWhereInput>
  }

  export type ConfiguracionProfesorOrderByWithRelationInput = {
    id?: SortOrder
    profesorId?: SortOrder
    nombreCurso?: SortOrder
    descripcionCurso?: SortOrderInput | SortOrder
    precioCurso?: SortOrder
    moneda?: SortOrder
    bioProfesor?: SortOrderInput | SortOrder
    fotoProfesorUrl?: SortOrderInput | SortOrder
    emailContacto?: SortOrderInput | SortOrder
    whatsappNumero?: SortOrderInput | SortOrder
    pais?: SortOrderInput | SortOrder
    stripeSecretKey?: SortOrderInput | SortOrder
    stripePublicKey?: SortOrderInput | SortOrder
    stripeWebhookSecret?: SortOrderInput | SortOrder
    emailNotificaciones?: SortOrderInput | SortOrder
    notificarWhatsApp?: SortOrder
    notificarEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profesor?: ProfesorOrderByWithRelationInput
  }

  export type ConfiguracionProfesorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profesorId?: string
    AND?: ConfiguracionProfesorWhereInput | ConfiguracionProfesorWhereInput[]
    OR?: ConfiguracionProfesorWhereInput[]
    NOT?: ConfiguracionProfesorWhereInput | ConfiguracionProfesorWhereInput[]
    nombreCurso?: StringFilter<"ConfiguracionProfesor"> | string
    descripcionCurso?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    precioCurso?: DecimalFilter<"ConfiguracionProfesor"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"ConfiguracionProfesor"> | string
    bioProfesor?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    fotoProfesorUrl?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    emailContacto?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    whatsappNumero?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    pais?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    stripeSecretKey?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    stripePublicKey?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    stripeWebhookSecret?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    emailNotificaciones?: StringNullableFilter<"ConfiguracionProfesor"> | string | null
    notificarWhatsApp?: BoolFilter<"ConfiguracionProfesor"> | boolean
    notificarEmail?: BoolFilter<"ConfiguracionProfesor"> | boolean
    createdAt?: DateTimeFilter<"ConfiguracionProfesor"> | Date | string
    updatedAt?: DateTimeFilter<"ConfiguracionProfesor"> | Date | string
    profesor?: XOR<ProfesorRelationFilter, ProfesorWhereInput>
  }, "id" | "profesorId">

  export type ConfiguracionProfesorOrderByWithAggregationInput = {
    id?: SortOrder
    profesorId?: SortOrder
    nombreCurso?: SortOrder
    descripcionCurso?: SortOrderInput | SortOrder
    precioCurso?: SortOrder
    moneda?: SortOrder
    bioProfesor?: SortOrderInput | SortOrder
    fotoProfesorUrl?: SortOrderInput | SortOrder
    emailContacto?: SortOrderInput | SortOrder
    whatsappNumero?: SortOrderInput | SortOrder
    pais?: SortOrderInput | SortOrder
    stripeSecretKey?: SortOrderInput | SortOrder
    stripePublicKey?: SortOrderInput | SortOrder
    stripeWebhookSecret?: SortOrderInput | SortOrder
    emailNotificaciones?: SortOrderInput | SortOrder
    notificarWhatsApp?: SortOrder
    notificarEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConfiguracionProfesorCountOrderByAggregateInput
    _avg?: ConfiguracionProfesorAvgOrderByAggregateInput
    _max?: ConfiguracionProfesorMaxOrderByAggregateInput
    _min?: ConfiguracionProfesorMinOrderByAggregateInput
    _sum?: ConfiguracionProfesorSumOrderByAggregateInput
  }

  export type ConfiguracionProfesorScalarWhereWithAggregatesInput = {
    AND?: ConfiguracionProfesorScalarWhereWithAggregatesInput | ConfiguracionProfesorScalarWhereWithAggregatesInput[]
    OR?: ConfiguracionProfesorScalarWhereWithAggregatesInput[]
    NOT?: ConfiguracionProfesorScalarWhereWithAggregatesInput | ConfiguracionProfesorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConfiguracionProfesor"> | string
    profesorId?: StringWithAggregatesFilter<"ConfiguracionProfesor"> | string
    nombreCurso?: StringWithAggregatesFilter<"ConfiguracionProfesor"> | string
    descripcionCurso?: StringNullableWithAggregatesFilter<"ConfiguracionProfesor"> | string | null
    precioCurso?: DecimalWithAggregatesFilter<"ConfiguracionProfesor"> | Decimal | DecimalJsLike | number | string
    moneda?: StringWithAggregatesFilter<"ConfiguracionProfesor"> | string
    bioProfesor?: StringNullableWithAggregatesFilter<"ConfiguracionProfesor"> | string | null
    fotoProfesorUrl?: StringNullableWithAggregatesFilter<"ConfiguracionProfesor"> | string | null
    emailContacto?: StringNullableWithAggregatesFilter<"ConfiguracionProfesor"> | string | null
    whatsappNumero?: StringNullableWithAggregatesFilter<"ConfiguracionProfesor"> | string | null
    pais?: StringNullableWithAggregatesFilter<"ConfiguracionProfesor"> | string | null
    stripeSecretKey?: StringNullableWithAggregatesFilter<"ConfiguracionProfesor"> | string | null
    stripePublicKey?: StringNullableWithAggregatesFilter<"ConfiguracionProfesor"> | string | null
    stripeWebhookSecret?: StringNullableWithAggregatesFilter<"ConfiguracionProfesor"> | string | null
    emailNotificaciones?: StringNullableWithAggregatesFilter<"ConfiguracionProfesor"> | string | null
    notificarWhatsApp?: BoolWithAggregatesFilter<"ConfiguracionProfesor"> | boolean
    notificarEmail?: BoolWithAggregatesFilter<"ConfiguracionProfesor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ConfiguracionProfesor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConfiguracionProfesor"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password?: string | null
    nombre: string
    avatarUrl?: string | null
    rol?: $Enums.UserRole
    estado?: $Enums.UserEstado
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutUserInput
    profesor?: ProfesorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password?: string | null
    nombre: string
    avatarUrl?: string | null
    rol?: $Enums.UserRole
    estado?: $Enums.UserEstado
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteUncheckedCreateNestedOneWithoutUserInput
    profesor?: ProfesorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    estado?: EnumUserEstadoFieldUpdateOperationsInput | $Enums.UserEstado
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutUserNestedInput
    profesor?: ProfesorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    estado?: EnumUserEstadoFieldUpdateOperationsInput | $Enums.UserEstado
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUncheckedUpdateOneWithoutUserNestedInput
    profesor?: ProfesorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password?: string | null
    nombre: string
    avatarUrl?: string | null
    rol?: $Enums.UserRole
    estado?: $Enums.UserEstado
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    estado?: EnumUserEstadoFieldUpdateOperationsInput | $Enums.UserEstado
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    estado?: EnumUserEstadoFieldUpdateOperationsInput | $Enums.UserEstado
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstudianteCreateInput = {
    id?: string
    estadoAprobacion?: $Enums.EstadoAprobacion
    estadoPago?: $Enums.EstadoPago
    fechaAprobacion?: Date | string | null
    fechaPago?: Date | string | null
    montoPagado?: Decimal | DecimalJsLike | number | string | null
    metodoPago?: string | null
    referenciaTransaccion?: string | null
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    fechaInscripcion?: Date | string | null
    user: UserCreateNestedOneWithoutEstudianteInput
    progreso?: ProgresoEstudianteCreateNestedManyWithoutEstudianteInput
    pagos?: PagoCreateNestedManyWithoutEstudianteInput
    solicitud?: SolicitudAccesoCreateNestedOneWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateInput = {
    id?: string
    userId: string
    estadoAprobacion?: $Enums.EstadoAprobacion
    estadoPago?: $Enums.EstadoPago
    fechaAprobacion?: Date | string | null
    fechaPago?: Date | string | null
    montoPagado?: Decimal | DecimalJsLike | number | string | null
    metodoPago?: string | null
    referenciaTransaccion?: string | null
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    fechaInscripcion?: Date | string | null
    progreso?: ProgresoEstudianteUncheckedCreateNestedManyWithoutEstudianteInput
    pagos?: PagoUncheckedCreateNestedManyWithoutEstudianteInput
    solicitud?: SolicitudAccesoUncheckedCreateNestedOneWithoutEstudianteInput
  }

  export type EstudianteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    estadoAprobacion?: EnumEstadoAprobacionFieldUpdateOperationsInput | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPagado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInscripcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutEstudianteNestedInput
    progreso?: ProgresoEstudianteUpdateManyWithoutEstudianteNestedInput
    pagos?: PagoUpdateManyWithoutEstudianteNestedInput
    solicitud?: SolicitudAccesoUpdateOneWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    estadoAprobacion?: EnumEstadoAprobacionFieldUpdateOperationsInput | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPagado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInscripcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progreso?: ProgresoEstudianteUncheckedUpdateManyWithoutEstudianteNestedInput
    pagos?: PagoUncheckedUpdateManyWithoutEstudianteNestedInput
    solicitud?: SolicitudAccesoUncheckedUpdateOneWithoutEstudianteNestedInput
  }

  export type EstudianteCreateManyInput = {
    id?: string
    userId: string
    estadoAprobacion?: $Enums.EstadoAprobacion
    estadoPago?: $Enums.EstadoPago
    fechaAprobacion?: Date | string | null
    fechaPago?: Date | string | null
    montoPagado?: Decimal | DecimalJsLike | number | string | null
    metodoPago?: string | null
    referenciaTransaccion?: string | null
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    fechaInscripcion?: Date | string | null
  }

  export type EstudianteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    estadoAprobacion?: EnumEstadoAprobacionFieldUpdateOperationsInput | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPagado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInscripcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EstudianteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    estadoAprobacion?: EnumEstadoAprobacionFieldUpdateOperationsInput | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPagado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInscripcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProfesorCreateInput = {
    id?: string
    permisos?: ProfesorCreatepermisosInput | string[]
    ultimoLogin?: Date | string | null
    user: UserCreateNestedOneWithoutProfesorInput
    configuracion?: ConfiguracionProfesorCreateNestedOneWithoutProfesorInput
  }

  export type ProfesorUncheckedCreateInput = {
    id?: string
    userId: string
    permisos?: ProfesorCreatepermisosInput | string[]
    ultimoLogin?: Date | string | null
    configuracion?: ConfiguracionProfesorUncheckedCreateNestedOneWithoutProfesorInput
  }

  export type ProfesorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permisos?: ProfesorUpdatepermisosInput | string[]
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProfesorNestedInput
    configuracion?: ConfiguracionProfesorUpdateOneWithoutProfesorNestedInput
  }

  export type ProfesorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permisos?: ProfesorUpdatepermisosInput | string[]
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuracion?: ConfiguracionProfesorUncheckedUpdateOneWithoutProfesorNestedInput
  }

  export type ProfesorCreateManyInput = {
    id?: string
    userId: string
    permisos?: ProfesorCreatepermisosInput | string[]
    ultimoLogin?: Date | string | null
  }

  export type ProfesorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permisos?: ProfesorUpdatepermisosInput | string[]
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProfesorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permisos?: ProfesorUpdatepermisosInput | string[]
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SolicitudAccesoCreateInput = {
    id?: string
    nombre: string
    email: string
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    estado?: $Enums.EstadoSolicitud
    fechaSolicitud?: Date | string
    fechaRevision?: Date | string | null
    motivoRechazo?: string | null
    createdAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutSolicitudInput
  }

  export type SolicitudAccesoUncheckedCreateInput = {
    id?: string
    estudianteId?: string | null
    nombre: string
    email: string
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    estado?: $Enums.EstadoSolicitud
    fechaSolicitud?: Date | string
    fechaRevision?: Date | string | null
    motivoRechazo?: string | null
    createdAt?: Date | string
  }

  export type SolicitudAccesoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoSolicitudFieldUpdateOperationsInput | $Enums.EstadoSolicitud
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutSolicitudNestedInput
  }

  export type SolicitudAccesoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoSolicitudFieldUpdateOperationsInput | $Enums.EstadoSolicitud
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolicitudAccesoCreateManyInput = {
    id?: string
    estudianteId?: string | null
    nombre: string
    email: string
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    estado?: $Enums.EstadoSolicitud
    fechaSolicitud?: Date | string
    fechaRevision?: Date | string | null
    motivoRechazo?: string | null
    createdAt?: Date | string
  }

  export type SolicitudAccesoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoSolicitudFieldUpdateOperationsInput | $Enums.EstadoSolicitud
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolicitudAccesoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoSolicitudFieldUpdateOperationsInput | $Enums.EstadoSolicitud
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuloCreateInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    orden?: number
    moduloPrevioId?: string | null
    contenido?: NullableJsonNullValueInput | InputJsonValue
    estado?: $Enums.EstadoModulo
    duracion?: string | null
    objetivos?: ModuloCreateobjetivosInput | string[]
    ejercicio?: NullableJsonNullValueInput | InputJsonValue
    recursos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    progreso?: ProgresoEstudianteCreateNestedManyWithoutModuloInput
  }

  export type ModuloUncheckedCreateInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    orden?: number
    moduloPrevioId?: string | null
    contenido?: NullableJsonNullValueInput | InputJsonValue
    estado?: $Enums.EstadoModulo
    duracion?: string | null
    objetivos?: ModuloCreateobjetivosInput | string[]
    ejercicio?: NullableJsonNullValueInput | InputJsonValue
    recursos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    progreso?: ProgresoEstudianteUncheckedCreateNestedManyWithoutModuloInput
  }

  export type ModuloUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    moduloPrevioId?: NullableStringFieldUpdateOperationsInput | string | null
    contenido?: NullableJsonNullValueInput | InputJsonValue
    estado?: EnumEstadoModuloFieldUpdateOperationsInput | $Enums.EstadoModulo
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    objetivos?: ModuloUpdateobjetivosInput | string[]
    ejercicio?: NullableJsonNullValueInput | InputJsonValue
    recursos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progreso?: ProgresoEstudianteUpdateManyWithoutModuloNestedInput
  }

  export type ModuloUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    moduloPrevioId?: NullableStringFieldUpdateOperationsInput | string | null
    contenido?: NullableJsonNullValueInput | InputJsonValue
    estado?: EnumEstadoModuloFieldUpdateOperationsInput | $Enums.EstadoModulo
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    objetivos?: ModuloUpdateobjetivosInput | string[]
    ejercicio?: NullableJsonNullValueInput | InputJsonValue
    recursos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progreso?: ProgresoEstudianteUncheckedUpdateManyWithoutModuloNestedInput
  }

  export type ModuloCreateManyInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    orden?: number
    moduloPrevioId?: string | null
    contenido?: NullableJsonNullValueInput | InputJsonValue
    estado?: $Enums.EstadoModulo
    duracion?: string | null
    objetivos?: ModuloCreateobjetivosInput | string[]
    ejercicio?: NullableJsonNullValueInput | InputJsonValue
    recursos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuloUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    moduloPrevioId?: NullableStringFieldUpdateOperationsInput | string | null
    contenido?: NullableJsonNullValueInput | InputJsonValue
    estado?: EnumEstadoModuloFieldUpdateOperationsInput | $Enums.EstadoModulo
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    objetivos?: ModuloUpdateobjetivosInput | string[]
    ejercicio?: NullableJsonNullValueInput | InputJsonValue
    recursos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuloUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    moduloPrevioId?: NullableStringFieldUpdateOperationsInput | string | null
    contenido?: NullableJsonNullValueInput | InputJsonValue
    estado?: EnumEstadoModuloFieldUpdateOperationsInput | $Enums.EstadoModulo
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    objetivos?: ModuloUpdateobjetivosInput | string[]
    ejercicio?: NullableJsonNullValueInput | InputJsonValue
    recursos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgresoEstudianteCreateInput = {
    id?: string
    completudPorcentaje?: number
    fechaCompletado?: Date | string | null
    ultimaActividad?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante: EstudianteCreateNestedOneWithoutProgresoInput
    modulo: ModuloCreateNestedOneWithoutProgresoInput
  }

  export type ProgresoEstudianteUncheckedCreateInput = {
    id?: string
    estudianteId: string
    moduloId: string
    completudPorcentaje?: number
    fechaCompletado?: Date | string | null
    ultimaActividad?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgresoEstudianteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completudPorcentaje?: IntFieldUpdateOperationsInput | number
    fechaCompletado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimaActividad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneRequiredWithoutProgresoNestedInput
    modulo?: ModuloUpdateOneRequiredWithoutProgresoNestedInput
  }

  export type ProgresoEstudianteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    completudPorcentaje?: IntFieldUpdateOperationsInput | number
    fechaCompletado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimaActividad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgresoEstudianteCreateManyInput = {
    id?: string
    estudianteId: string
    moduloId: string
    completudPorcentaje?: number
    fechaCompletado?: Date | string | null
    ultimaActividad?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgresoEstudianteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completudPorcentaje?: IntFieldUpdateOperationsInput | number
    fechaCompletado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimaActividad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgresoEstudianteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    completudPorcentaje?: IntFieldUpdateOperationsInput | number
    fechaCompletado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimaActividad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoCreateInput = {
    id?: string
    monto: Decimal | DecimalJsLike | number | string
    moneda?: string
    proveedor: string
    referenciaExterna: string
    estado?: $Enums.EstadoPagoTransaccion
    fechaPago?: Date | string | null
    createdAt?: Date | string
    estudiante: EstudianteCreateNestedOneWithoutPagosInput
  }

  export type PagoUncheckedCreateInput = {
    id?: string
    estudianteId: string
    monto: Decimal | DecimalJsLike | number | string
    moneda?: string
    proveedor: string
    referenciaExterna: string
    estado?: $Enums.EstadoPagoTransaccion
    fechaPago?: Date | string | null
    createdAt?: Date | string
  }

  export type PagoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    referenciaExterna?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoPagoTransaccionFieldUpdateOperationsInput | $Enums.EstadoPagoTransaccion
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneRequiredWithoutPagosNestedInput
  }

  export type PagoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    referenciaExterna?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoPagoTransaccionFieldUpdateOperationsInput | $Enums.EstadoPagoTransaccion
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoCreateManyInput = {
    id?: string
    estudianteId: string
    monto: Decimal | DecimalJsLike | number | string
    moneda?: string
    proveedor: string
    referenciaExterna: string
    estado?: $Enums.EstadoPagoTransaccion
    fechaPago?: Date | string | null
    createdAt?: Date | string
  }

  export type PagoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    referenciaExterna?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoPagoTransaccionFieldUpdateOperationsInput | $Enums.EstadoPagoTransaccion
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    referenciaExterna?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoPagoTransaccionFieldUpdateOperationsInput | $Enums.EstadoPagoTransaccion
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionProfesorCreateInput = {
    id?: string
    nombreCurso: string
    descripcionCurso?: string | null
    precioCurso: Decimal | DecimalJsLike | number | string
    moneda?: string
    bioProfesor?: string | null
    fotoProfesorUrl?: string | null
    emailContacto?: string | null
    whatsappNumero?: string | null
    pais?: string | null
    stripeSecretKey?: string | null
    stripePublicKey?: string | null
    stripeWebhookSecret?: string | null
    emailNotificaciones?: string | null
    notificarWhatsApp?: boolean
    notificarEmail?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profesor: ProfesorCreateNestedOneWithoutConfiguracionInput
  }

  export type ConfiguracionProfesorUncheckedCreateInput = {
    id?: string
    profesorId: string
    nombreCurso: string
    descripcionCurso?: string | null
    precioCurso: Decimal | DecimalJsLike | number | string
    moneda?: string
    bioProfesor?: string | null
    fotoProfesorUrl?: string | null
    emailContacto?: string | null
    whatsappNumero?: string | null
    pais?: string | null
    stripeSecretKey?: string | null
    stripePublicKey?: string | null
    stripeWebhookSecret?: string | null
    emailNotificaciones?: string | null
    notificarWhatsApp?: boolean
    notificarEmail?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfiguracionProfesorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreCurso?: StringFieldUpdateOperationsInput | string
    descripcionCurso?: NullableStringFieldUpdateOperationsInput | string | null
    precioCurso?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    bioProfesor?: NullableStringFieldUpdateOperationsInput | string | null
    fotoProfesorUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailContacto?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumero?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripePublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    notificarWhatsApp?: BoolFieldUpdateOperationsInput | boolean
    notificarEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profesor?: ProfesorUpdateOneRequiredWithoutConfiguracionNestedInput
  }

  export type ConfiguracionProfesorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profesorId?: StringFieldUpdateOperationsInput | string
    nombreCurso?: StringFieldUpdateOperationsInput | string
    descripcionCurso?: NullableStringFieldUpdateOperationsInput | string | null
    precioCurso?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    bioProfesor?: NullableStringFieldUpdateOperationsInput | string | null
    fotoProfesorUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailContacto?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumero?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripePublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    notificarWhatsApp?: BoolFieldUpdateOperationsInput | boolean
    notificarEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionProfesorCreateManyInput = {
    id?: string
    profesorId: string
    nombreCurso: string
    descripcionCurso?: string | null
    precioCurso: Decimal | DecimalJsLike | number | string
    moneda?: string
    bioProfesor?: string | null
    fotoProfesorUrl?: string | null
    emailContacto?: string | null
    whatsappNumero?: string | null
    pais?: string | null
    stripeSecretKey?: string | null
    stripePublicKey?: string | null
    stripeWebhookSecret?: string | null
    emailNotificaciones?: string | null
    notificarWhatsApp?: boolean
    notificarEmail?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfiguracionProfesorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreCurso?: StringFieldUpdateOperationsInput | string
    descripcionCurso?: NullableStringFieldUpdateOperationsInput | string | null
    precioCurso?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    bioProfesor?: NullableStringFieldUpdateOperationsInput | string | null
    fotoProfesorUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailContacto?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumero?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripePublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    notificarWhatsApp?: BoolFieldUpdateOperationsInput | boolean
    notificarEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionProfesorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profesorId?: StringFieldUpdateOperationsInput | string
    nombreCurso?: StringFieldUpdateOperationsInput | string
    descripcionCurso?: NullableStringFieldUpdateOperationsInput | string | null
    precioCurso?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    bioProfesor?: NullableStringFieldUpdateOperationsInput | string | null
    fotoProfesorUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailContacto?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumero?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripePublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    notificarWhatsApp?: BoolFieldUpdateOperationsInput | boolean
    notificarEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.UserEstado | EnumUserEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.UserEstado[] | ListEnumUserEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserEstado[] | ListEnumUserEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumUserEstadoFilter<$PrismaModel> | $Enums.UserEstado
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EstudianteNullableRelationFilter = {
    is?: EstudianteWhereInput | null
    isNot?: EstudianteWhereInput | null
  }

  export type ProfesorNullableRelationFilter = {
    is?: ProfesorWhereInput | null
    isNot?: ProfesorWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nombre?: SortOrder
    avatarUrl?: SortOrder
    rol?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nombre?: SortOrder
    avatarUrl?: SortOrder
    rol?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nombre?: SortOrder
    avatarUrl?: SortOrder
    rol?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserEstado | EnumUserEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.UserEstado[] | ListEnumUserEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserEstado[] | ListEnumUserEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumUserEstadoWithAggregatesFilter<$PrismaModel> | $Enums.UserEstado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserEstadoFilter<$PrismaModel>
    _max?: NestedEnumUserEstadoFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumEstadoAprobacionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoAprobacion | EnumEstadoAprobacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoAprobacion[] | ListEnumEstadoAprobacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoAprobacion[] | ListEnumEstadoAprobacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoAprobacionFilter<$PrismaModel> | $Enums.EstadoAprobacion
  }

  export type EnumEstadoPagoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPago | EnumEstadoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoFilter<$PrismaModel> | $Enums.EstadoPago
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProgresoEstudianteListRelationFilter = {
    every?: ProgresoEstudianteWhereInput
    some?: ProgresoEstudianteWhereInput
    none?: ProgresoEstudianteWhereInput
  }

  export type PagoListRelationFilter = {
    every?: PagoWhereInput
    some?: PagoWhereInput
    none?: PagoWhereInput
  }

  export type SolicitudAccesoNullableRelationFilter = {
    is?: SolicitudAccesoWhereInput | null
    isNot?: SolicitudAccesoWhereInput | null
  }

  export type ProgresoEstudianteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PagoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EstudianteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    estadoAprobacion?: SortOrder
    estadoPago?: SortOrder
    fechaAprobacion?: SortOrder
    fechaPago?: SortOrder
    montoPagado?: SortOrder
    metodoPago?: SortOrder
    referenciaTransaccion?: SortOrder
    telefono?: SortOrder
    pais?: SortOrder
    experiencia?: SortOrder
    interes?: SortOrder
    fechaInscripcion?: SortOrder
  }

  export type EstudianteAvgOrderByAggregateInput = {
    montoPagado?: SortOrder
  }

  export type EstudianteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    estadoAprobacion?: SortOrder
    estadoPago?: SortOrder
    fechaAprobacion?: SortOrder
    fechaPago?: SortOrder
    montoPagado?: SortOrder
    metodoPago?: SortOrder
    referenciaTransaccion?: SortOrder
    telefono?: SortOrder
    pais?: SortOrder
    experiencia?: SortOrder
    interes?: SortOrder
    fechaInscripcion?: SortOrder
  }

  export type EstudianteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    estadoAprobacion?: SortOrder
    estadoPago?: SortOrder
    fechaAprobacion?: SortOrder
    fechaPago?: SortOrder
    montoPagado?: SortOrder
    metodoPago?: SortOrder
    referenciaTransaccion?: SortOrder
    telefono?: SortOrder
    pais?: SortOrder
    experiencia?: SortOrder
    interes?: SortOrder
    fechaInscripcion?: SortOrder
  }

  export type EstudianteSumOrderByAggregateInput = {
    montoPagado?: SortOrder
  }

  export type EnumEstadoAprobacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoAprobacion | EnumEstadoAprobacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoAprobacion[] | ListEnumEstadoAprobacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoAprobacion[] | ListEnumEstadoAprobacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoAprobacionWithAggregatesFilter<$PrismaModel> | $Enums.EstadoAprobacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoAprobacionFilter<$PrismaModel>
    _max?: NestedEnumEstadoAprobacionFilter<$PrismaModel>
  }

  export type EnumEstadoPagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPago | EnumEstadoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPagoFilter<$PrismaModel>
    _max?: NestedEnumEstadoPagoFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ConfiguracionProfesorNullableRelationFilter = {
    is?: ConfiguracionProfesorWhereInput | null
    isNot?: ConfiguracionProfesorWhereInput | null
  }

  export type ProfesorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permisos?: SortOrder
    ultimoLogin?: SortOrder
  }

  export type ProfesorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ultimoLogin?: SortOrder
  }

  export type ProfesorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ultimoLogin?: SortOrder
  }

  export type EnumEstadoSolicitudFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoSolicitud | EnumEstadoSolicitudFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoSolicitud[] | ListEnumEstadoSolicitudFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoSolicitud[] | ListEnumEstadoSolicitudFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoSolicitudFilter<$PrismaModel> | $Enums.EstadoSolicitud
  }

  export type SolicitudAccesoCountOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    pais?: SortOrder
    experiencia?: SortOrder
    interes?: SortOrder
    estado?: SortOrder
    fechaSolicitud?: SortOrder
    fechaRevision?: SortOrder
    motivoRechazo?: SortOrder
    createdAt?: SortOrder
  }

  export type SolicitudAccesoMaxOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    pais?: SortOrder
    experiencia?: SortOrder
    interes?: SortOrder
    estado?: SortOrder
    fechaSolicitud?: SortOrder
    fechaRevision?: SortOrder
    motivoRechazo?: SortOrder
    createdAt?: SortOrder
  }

  export type SolicitudAccesoMinOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    pais?: SortOrder
    experiencia?: SortOrder
    interes?: SortOrder
    estado?: SortOrder
    fechaSolicitud?: SortOrder
    fechaRevision?: SortOrder
    motivoRechazo?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumEstadoSolicitudWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoSolicitud | EnumEstadoSolicitudFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoSolicitud[] | ListEnumEstadoSolicitudFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoSolicitud[] | ListEnumEstadoSolicitudFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoSolicitudWithAggregatesFilter<$PrismaModel> | $Enums.EstadoSolicitud
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoSolicitudFilter<$PrismaModel>
    _max?: NestedEnumEstadoSolicitudFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumEstadoModuloFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoModulo | EnumEstadoModuloFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoModulo[] | ListEnumEstadoModuloFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoModulo[] | ListEnumEstadoModuloFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoModuloFilter<$PrismaModel> | $Enums.EstadoModulo
  }

  export type ModuloCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    moduloPrevioId?: SortOrder
    contenido?: SortOrder
    estado?: SortOrder
    duracion?: SortOrder
    objetivos?: SortOrder
    ejercicio?: SortOrder
    recursos?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuloAvgOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type ModuloMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    moduloPrevioId?: SortOrder
    estado?: SortOrder
    duracion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuloMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    moduloPrevioId?: SortOrder
    estado?: SortOrder
    duracion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuloSumOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumEstadoModuloWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoModulo | EnumEstadoModuloFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoModulo[] | ListEnumEstadoModuloFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoModulo[] | ListEnumEstadoModuloFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoModuloWithAggregatesFilter<$PrismaModel> | $Enums.EstadoModulo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoModuloFilter<$PrismaModel>
    _max?: NestedEnumEstadoModuloFilter<$PrismaModel>
  }

  export type EstudianteRelationFilter = {
    is?: EstudianteWhereInput
    isNot?: EstudianteWhereInput
  }

  export type ModuloRelationFilter = {
    is?: ModuloWhereInput
    isNot?: ModuloWhereInput
  }

  export type ProgresoEstudianteEstudianteIdModuloIdCompoundUniqueInput = {
    estudianteId: string
    moduloId: string
  }

  export type ProgresoEstudianteCountOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    moduloId?: SortOrder
    completudPorcentaje?: SortOrder
    fechaCompletado?: SortOrder
    ultimaActividad?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgresoEstudianteAvgOrderByAggregateInput = {
    completudPorcentaje?: SortOrder
  }

  export type ProgresoEstudianteMaxOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    moduloId?: SortOrder
    completudPorcentaje?: SortOrder
    fechaCompletado?: SortOrder
    ultimaActividad?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgresoEstudianteMinOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    moduloId?: SortOrder
    completudPorcentaje?: SortOrder
    fechaCompletado?: SortOrder
    ultimaActividad?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgresoEstudianteSumOrderByAggregateInput = {
    completudPorcentaje?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumEstadoPagoTransaccionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPagoTransaccion | EnumEstadoPagoTransaccionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPagoTransaccion[] | ListEnumEstadoPagoTransaccionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPagoTransaccion[] | ListEnumEstadoPagoTransaccionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoTransaccionFilter<$PrismaModel> | $Enums.EstadoPagoTransaccion
  }

  export type PagoCountOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    proveedor?: SortOrder
    referenciaExterna?: SortOrder
    estado?: SortOrder
    fechaPago?: SortOrder
    createdAt?: SortOrder
  }

  export type PagoAvgOrderByAggregateInput = {
    monto?: SortOrder
  }

  export type PagoMaxOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    proveedor?: SortOrder
    referenciaExterna?: SortOrder
    estado?: SortOrder
    fechaPago?: SortOrder
    createdAt?: SortOrder
  }

  export type PagoMinOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    proveedor?: SortOrder
    referenciaExterna?: SortOrder
    estado?: SortOrder
    fechaPago?: SortOrder
    createdAt?: SortOrder
  }

  export type PagoSumOrderByAggregateInput = {
    monto?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumEstadoPagoTransaccionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPagoTransaccion | EnumEstadoPagoTransaccionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPagoTransaccion[] | ListEnumEstadoPagoTransaccionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPagoTransaccion[] | ListEnumEstadoPagoTransaccionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoTransaccionWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPagoTransaccion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPagoTransaccionFilter<$PrismaModel>
    _max?: NestedEnumEstadoPagoTransaccionFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProfesorRelationFilter = {
    is?: ProfesorWhereInput
    isNot?: ProfesorWhereInput
  }

  export type ConfiguracionProfesorCountOrderByAggregateInput = {
    id?: SortOrder
    profesorId?: SortOrder
    nombreCurso?: SortOrder
    descripcionCurso?: SortOrder
    precioCurso?: SortOrder
    moneda?: SortOrder
    bioProfesor?: SortOrder
    fotoProfesorUrl?: SortOrder
    emailContacto?: SortOrder
    whatsappNumero?: SortOrder
    pais?: SortOrder
    stripeSecretKey?: SortOrder
    stripePublicKey?: SortOrder
    stripeWebhookSecret?: SortOrder
    emailNotificaciones?: SortOrder
    notificarWhatsApp?: SortOrder
    notificarEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfiguracionProfesorAvgOrderByAggregateInput = {
    precioCurso?: SortOrder
  }

  export type ConfiguracionProfesorMaxOrderByAggregateInput = {
    id?: SortOrder
    profesorId?: SortOrder
    nombreCurso?: SortOrder
    descripcionCurso?: SortOrder
    precioCurso?: SortOrder
    moneda?: SortOrder
    bioProfesor?: SortOrder
    fotoProfesorUrl?: SortOrder
    emailContacto?: SortOrder
    whatsappNumero?: SortOrder
    pais?: SortOrder
    stripeSecretKey?: SortOrder
    stripePublicKey?: SortOrder
    stripeWebhookSecret?: SortOrder
    emailNotificaciones?: SortOrder
    notificarWhatsApp?: SortOrder
    notificarEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfiguracionProfesorMinOrderByAggregateInput = {
    id?: SortOrder
    profesorId?: SortOrder
    nombreCurso?: SortOrder
    descripcionCurso?: SortOrder
    precioCurso?: SortOrder
    moneda?: SortOrder
    bioProfesor?: SortOrder
    fotoProfesorUrl?: SortOrder
    emailContacto?: SortOrder
    whatsappNumero?: SortOrder
    pais?: SortOrder
    stripeSecretKey?: SortOrder
    stripePublicKey?: SortOrder
    stripeWebhookSecret?: SortOrder
    emailNotificaciones?: SortOrder
    notificarWhatsApp?: SortOrder
    notificarEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfiguracionProfesorSumOrderByAggregateInput = {
    precioCurso?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EstudianteCreateNestedOneWithoutUserInput = {
    create?: XOR<EstudianteCreateWithoutUserInput, EstudianteUncheckedCreateWithoutUserInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutUserInput
    connect?: EstudianteWhereUniqueInput
  }

  export type ProfesorCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfesorCreateWithoutUserInput, ProfesorUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutUserInput
    connect?: ProfesorWhereUniqueInput
  }

  export type EstudianteUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EstudianteCreateWithoutUserInput, EstudianteUncheckedCreateWithoutUserInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutUserInput
    connect?: EstudianteWhereUniqueInput
  }

  export type ProfesorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfesorCreateWithoutUserInput, ProfesorUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutUserInput
    connect?: ProfesorWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserEstadoFieldUpdateOperationsInput = {
    set?: $Enums.UserEstado
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EstudianteUpdateOneWithoutUserNestedInput = {
    create?: XOR<EstudianteCreateWithoutUserInput, EstudianteUncheckedCreateWithoutUserInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutUserInput
    upsert?: EstudianteUpsertWithoutUserInput
    disconnect?: EstudianteWhereInput | boolean
    delete?: EstudianteWhereInput | boolean
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutUserInput, EstudianteUpdateWithoutUserInput>, EstudianteUncheckedUpdateWithoutUserInput>
  }

  export type ProfesorUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfesorCreateWithoutUserInput, ProfesorUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutUserInput
    upsert?: ProfesorUpsertWithoutUserInput
    disconnect?: ProfesorWhereInput | boolean
    delete?: ProfesorWhereInput | boolean
    connect?: ProfesorWhereUniqueInput
    update?: XOR<XOR<ProfesorUpdateToOneWithWhereWithoutUserInput, ProfesorUpdateWithoutUserInput>, ProfesorUncheckedUpdateWithoutUserInput>
  }

  export type EstudianteUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EstudianteCreateWithoutUserInput, EstudianteUncheckedCreateWithoutUserInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutUserInput
    upsert?: EstudianteUpsertWithoutUserInput
    disconnect?: EstudianteWhereInput | boolean
    delete?: EstudianteWhereInput | boolean
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutUserInput, EstudianteUpdateWithoutUserInput>, EstudianteUncheckedUpdateWithoutUserInput>
  }

  export type ProfesorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfesorCreateWithoutUserInput, ProfesorUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutUserInput
    upsert?: ProfesorUpsertWithoutUserInput
    disconnect?: ProfesorWhereInput | boolean
    delete?: ProfesorWhereInput | boolean
    connect?: ProfesorWhereUniqueInput
    update?: XOR<XOR<ProfesorUpdateToOneWithWhereWithoutUserInput, ProfesorUpdateWithoutUserInput>, ProfesorUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutEstudianteInput = {
    create?: XOR<UserCreateWithoutEstudianteInput, UserUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: UserCreateOrConnectWithoutEstudianteInput
    connect?: UserWhereUniqueInput
  }

  export type ProgresoEstudianteCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<ProgresoEstudianteCreateWithoutEstudianteInput, ProgresoEstudianteUncheckedCreateWithoutEstudianteInput> | ProgresoEstudianteCreateWithoutEstudianteInput[] | ProgresoEstudianteUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: ProgresoEstudianteCreateOrConnectWithoutEstudianteInput | ProgresoEstudianteCreateOrConnectWithoutEstudianteInput[]
    createMany?: ProgresoEstudianteCreateManyEstudianteInputEnvelope
    connect?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
  }

  export type PagoCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<PagoCreateWithoutEstudianteInput, PagoUncheckedCreateWithoutEstudianteInput> | PagoCreateWithoutEstudianteInput[] | PagoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutEstudianteInput | PagoCreateOrConnectWithoutEstudianteInput[]
    createMany?: PagoCreateManyEstudianteInputEnvelope
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
  }

  export type SolicitudAccesoCreateNestedOneWithoutEstudianteInput = {
    create?: XOR<SolicitudAccesoCreateWithoutEstudianteInput, SolicitudAccesoUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: SolicitudAccesoCreateOrConnectWithoutEstudianteInput
    connect?: SolicitudAccesoWhereUniqueInput
  }

  export type ProgresoEstudianteUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<ProgresoEstudianteCreateWithoutEstudianteInput, ProgresoEstudianteUncheckedCreateWithoutEstudianteInput> | ProgresoEstudianteCreateWithoutEstudianteInput[] | ProgresoEstudianteUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: ProgresoEstudianteCreateOrConnectWithoutEstudianteInput | ProgresoEstudianteCreateOrConnectWithoutEstudianteInput[]
    createMany?: ProgresoEstudianteCreateManyEstudianteInputEnvelope
    connect?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
  }

  export type PagoUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<PagoCreateWithoutEstudianteInput, PagoUncheckedCreateWithoutEstudianteInput> | PagoCreateWithoutEstudianteInput[] | PagoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutEstudianteInput | PagoCreateOrConnectWithoutEstudianteInput[]
    createMany?: PagoCreateManyEstudianteInputEnvelope
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
  }

  export type SolicitudAccesoUncheckedCreateNestedOneWithoutEstudianteInput = {
    create?: XOR<SolicitudAccesoCreateWithoutEstudianteInput, SolicitudAccesoUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: SolicitudAccesoCreateOrConnectWithoutEstudianteInput
    connect?: SolicitudAccesoWhereUniqueInput
  }

  export type EnumEstadoAprobacionFieldUpdateOperationsInput = {
    set?: $Enums.EstadoAprobacion
  }

  export type EnumEstadoPagoFieldUpdateOperationsInput = {
    set?: $Enums.EstadoPago
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutEstudianteNestedInput = {
    create?: XOR<UserCreateWithoutEstudianteInput, UserUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: UserCreateOrConnectWithoutEstudianteInput
    upsert?: UserUpsertWithoutEstudianteInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEstudianteInput, UserUpdateWithoutEstudianteInput>, UserUncheckedUpdateWithoutEstudianteInput>
  }

  export type ProgresoEstudianteUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<ProgresoEstudianteCreateWithoutEstudianteInput, ProgresoEstudianteUncheckedCreateWithoutEstudianteInput> | ProgresoEstudianteCreateWithoutEstudianteInput[] | ProgresoEstudianteUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: ProgresoEstudianteCreateOrConnectWithoutEstudianteInput | ProgresoEstudianteCreateOrConnectWithoutEstudianteInput[]
    upsert?: ProgresoEstudianteUpsertWithWhereUniqueWithoutEstudianteInput | ProgresoEstudianteUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: ProgresoEstudianteCreateManyEstudianteInputEnvelope
    set?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    disconnect?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    delete?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    connect?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    update?: ProgresoEstudianteUpdateWithWhereUniqueWithoutEstudianteInput | ProgresoEstudianteUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: ProgresoEstudianteUpdateManyWithWhereWithoutEstudianteInput | ProgresoEstudianteUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: ProgresoEstudianteScalarWhereInput | ProgresoEstudianteScalarWhereInput[]
  }

  export type PagoUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<PagoCreateWithoutEstudianteInput, PagoUncheckedCreateWithoutEstudianteInput> | PagoCreateWithoutEstudianteInput[] | PagoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutEstudianteInput | PagoCreateOrConnectWithoutEstudianteInput[]
    upsert?: PagoUpsertWithWhereUniqueWithoutEstudianteInput | PagoUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: PagoCreateManyEstudianteInputEnvelope
    set?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    disconnect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    delete?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    update?: PagoUpdateWithWhereUniqueWithoutEstudianteInput | PagoUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: PagoUpdateManyWithWhereWithoutEstudianteInput | PagoUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: PagoScalarWhereInput | PagoScalarWhereInput[]
  }

  export type SolicitudAccesoUpdateOneWithoutEstudianteNestedInput = {
    create?: XOR<SolicitudAccesoCreateWithoutEstudianteInput, SolicitudAccesoUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: SolicitudAccesoCreateOrConnectWithoutEstudianteInput
    upsert?: SolicitudAccesoUpsertWithoutEstudianteInput
    disconnect?: SolicitudAccesoWhereInput | boolean
    delete?: SolicitudAccesoWhereInput | boolean
    connect?: SolicitudAccesoWhereUniqueInput
    update?: XOR<XOR<SolicitudAccesoUpdateToOneWithWhereWithoutEstudianteInput, SolicitudAccesoUpdateWithoutEstudianteInput>, SolicitudAccesoUncheckedUpdateWithoutEstudianteInput>
  }

  export type ProgresoEstudianteUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<ProgresoEstudianteCreateWithoutEstudianteInput, ProgresoEstudianteUncheckedCreateWithoutEstudianteInput> | ProgresoEstudianteCreateWithoutEstudianteInput[] | ProgresoEstudianteUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: ProgresoEstudianteCreateOrConnectWithoutEstudianteInput | ProgresoEstudianteCreateOrConnectWithoutEstudianteInput[]
    upsert?: ProgresoEstudianteUpsertWithWhereUniqueWithoutEstudianteInput | ProgresoEstudianteUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: ProgresoEstudianteCreateManyEstudianteInputEnvelope
    set?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    disconnect?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    delete?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    connect?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    update?: ProgresoEstudianteUpdateWithWhereUniqueWithoutEstudianteInput | ProgresoEstudianteUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: ProgresoEstudianteUpdateManyWithWhereWithoutEstudianteInput | ProgresoEstudianteUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: ProgresoEstudianteScalarWhereInput | ProgresoEstudianteScalarWhereInput[]
  }

  export type PagoUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<PagoCreateWithoutEstudianteInput, PagoUncheckedCreateWithoutEstudianteInput> | PagoCreateWithoutEstudianteInput[] | PagoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutEstudianteInput | PagoCreateOrConnectWithoutEstudianteInput[]
    upsert?: PagoUpsertWithWhereUniqueWithoutEstudianteInput | PagoUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: PagoCreateManyEstudianteInputEnvelope
    set?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    disconnect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    delete?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    update?: PagoUpdateWithWhereUniqueWithoutEstudianteInput | PagoUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: PagoUpdateManyWithWhereWithoutEstudianteInput | PagoUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: PagoScalarWhereInput | PagoScalarWhereInput[]
  }

  export type SolicitudAccesoUncheckedUpdateOneWithoutEstudianteNestedInput = {
    create?: XOR<SolicitudAccesoCreateWithoutEstudianteInput, SolicitudAccesoUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: SolicitudAccesoCreateOrConnectWithoutEstudianteInput
    upsert?: SolicitudAccesoUpsertWithoutEstudianteInput
    disconnect?: SolicitudAccesoWhereInput | boolean
    delete?: SolicitudAccesoWhereInput | boolean
    connect?: SolicitudAccesoWhereUniqueInput
    update?: XOR<XOR<SolicitudAccesoUpdateToOneWithWhereWithoutEstudianteInput, SolicitudAccesoUpdateWithoutEstudianteInput>, SolicitudAccesoUncheckedUpdateWithoutEstudianteInput>
  }

  export type ProfesorCreatepermisosInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutProfesorInput = {
    create?: XOR<UserCreateWithoutProfesorInput, UserUncheckedCreateWithoutProfesorInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfesorInput
    connect?: UserWhereUniqueInput
  }

  export type ConfiguracionProfesorCreateNestedOneWithoutProfesorInput = {
    create?: XOR<ConfiguracionProfesorCreateWithoutProfesorInput, ConfiguracionProfesorUncheckedCreateWithoutProfesorInput>
    connectOrCreate?: ConfiguracionProfesorCreateOrConnectWithoutProfesorInput
    connect?: ConfiguracionProfesorWhereUniqueInput
  }

  export type ConfiguracionProfesorUncheckedCreateNestedOneWithoutProfesorInput = {
    create?: XOR<ConfiguracionProfesorCreateWithoutProfesorInput, ConfiguracionProfesorUncheckedCreateWithoutProfesorInput>
    connectOrCreate?: ConfiguracionProfesorCreateOrConnectWithoutProfesorInput
    connect?: ConfiguracionProfesorWhereUniqueInput
  }

  export type ProfesorUpdatepermisosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutProfesorNestedInput = {
    create?: XOR<UserCreateWithoutProfesorInput, UserUncheckedCreateWithoutProfesorInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfesorInput
    upsert?: UserUpsertWithoutProfesorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfesorInput, UserUpdateWithoutProfesorInput>, UserUncheckedUpdateWithoutProfesorInput>
  }

  export type ConfiguracionProfesorUpdateOneWithoutProfesorNestedInput = {
    create?: XOR<ConfiguracionProfesorCreateWithoutProfesorInput, ConfiguracionProfesorUncheckedCreateWithoutProfesorInput>
    connectOrCreate?: ConfiguracionProfesorCreateOrConnectWithoutProfesorInput
    upsert?: ConfiguracionProfesorUpsertWithoutProfesorInput
    disconnect?: ConfiguracionProfesorWhereInput | boolean
    delete?: ConfiguracionProfesorWhereInput | boolean
    connect?: ConfiguracionProfesorWhereUniqueInput
    update?: XOR<XOR<ConfiguracionProfesorUpdateToOneWithWhereWithoutProfesorInput, ConfiguracionProfesorUpdateWithoutProfesorInput>, ConfiguracionProfesorUncheckedUpdateWithoutProfesorInput>
  }

  export type ConfiguracionProfesorUncheckedUpdateOneWithoutProfesorNestedInput = {
    create?: XOR<ConfiguracionProfesorCreateWithoutProfesorInput, ConfiguracionProfesorUncheckedCreateWithoutProfesorInput>
    connectOrCreate?: ConfiguracionProfesorCreateOrConnectWithoutProfesorInput
    upsert?: ConfiguracionProfesorUpsertWithoutProfesorInput
    disconnect?: ConfiguracionProfesorWhereInput | boolean
    delete?: ConfiguracionProfesorWhereInput | boolean
    connect?: ConfiguracionProfesorWhereUniqueInput
    update?: XOR<XOR<ConfiguracionProfesorUpdateToOneWithWhereWithoutProfesorInput, ConfiguracionProfesorUpdateWithoutProfesorInput>, ConfiguracionProfesorUncheckedUpdateWithoutProfesorInput>
  }

  export type EstudianteCreateNestedOneWithoutSolicitudInput = {
    create?: XOR<EstudianteCreateWithoutSolicitudInput, EstudianteUncheckedCreateWithoutSolicitudInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutSolicitudInput
    connect?: EstudianteWhereUniqueInput
  }

  export type EnumEstadoSolicitudFieldUpdateOperationsInput = {
    set?: $Enums.EstadoSolicitud
  }

  export type EstudianteUpdateOneWithoutSolicitudNestedInput = {
    create?: XOR<EstudianteCreateWithoutSolicitudInput, EstudianteUncheckedCreateWithoutSolicitudInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutSolicitudInput
    upsert?: EstudianteUpsertWithoutSolicitudInput
    disconnect?: EstudianteWhereInput | boolean
    delete?: EstudianteWhereInput | boolean
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutSolicitudInput, EstudianteUpdateWithoutSolicitudInput>, EstudianteUncheckedUpdateWithoutSolicitudInput>
  }

  export type ModuloCreateobjetivosInput = {
    set: string[]
  }

  export type ProgresoEstudianteCreateNestedManyWithoutModuloInput = {
    create?: XOR<ProgresoEstudianteCreateWithoutModuloInput, ProgresoEstudianteUncheckedCreateWithoutModuloInput> | ProgresoEstudianteCreateWithoutModuloInput[] | ProgresoEstudianteUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ProgresoEstudianteCreateOrConnectWithoutModuloInput | ProgresoEstudianteCreateOrConnectWithoutModuloInput[]
    createMany?: ProgresoEstudianteCreateManyModuloInputEnvelope
    connect?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
  }

  export type ProgresoEstudianteUncheckedCreateNestedManyWithoutModuloInput = {
    create?: XOR<ProgresoEstudianteCreateWithoutModuloInput, ProgresoEstudianteUncheckedCreateWithoutModuloInput> | ProgresoEstudianteCreateWithoutModuloInput[] | ProgresoEstudianteUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ProgresoEstudianteCreateOrConnectWithoutModuloInput | ProgresoEstudianteCreateOrConnectWithoutModuloInput[]
    createMany?: ProgresoEstudianteCreateManyModuloInputEnvelope
    connect?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumEstadoModuloFieldUpdateOperationsInput = {
    set?: $Enums.EstadoModulo
  }

  export type ModuloUpdateobjetivosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProgresoEstudianteUpdateManyWithoutModuloNestedInput = {
    create?: XOR<ProgresoEstudianteCreateWithoutModuloInput, ProgresoEstudianteUncheckedCreateWithoutModuloInput> | ProgresoEstudianteCreateWithoutModuloInput[] | ProgresoEstudianteUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ProgresoEstudianteCreateOrConnectWithoutModuloInput | ProgresoEstudianteCreateOrConnectWithoutModuloInput[]
    upsert?: ProgresoEstudianteUpsertWithWhereUniqueWithoutModuloInput | ProgresoEstudianteUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: ProgresoEstudianteCreateManyModuloInputEnvelope
    set?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    disconnect?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    delete?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    connect?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    update?: ProgresoEstudianteUpdateWithWhereUniqueWithoutModuloInput | ProgresoEstudianteUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: ProgresoEstudianteUpdateManyWithWhereWithoutModuloInput | ProgresoEstudianteUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: ProgresoEstudianteScalarWhereInput | ProgresoEstudianteScalarWhereInput[]
  }

  export type ProgresoEstudianteUncheckedUpdateManyWithoutModuloNestedInput = {
    create?: XOR<ProgresoEstudianteCreateWithoutModuloInput, ProgresoEstudianteUncheckedCreateWithoutModuloInput> | ProgresoEstudianteCreateWithoutModuloInput[] | ProgresoEstudianteUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: ProgresoEstudianteCreateOrConnectWithoutModuloInput | ProgresoEstudianteCreateOrConnectWithoutModuloInput[]
    upsert?: ProgresoEstudianteUpsertWithWhereUniqueWithoutModuloInput | ProgresoEstudianteUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: ProgresoEstudianteCreateManyModuloInputEnvelope
    set?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    disconnect?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    delete?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    connect?: ProgresoEstudianteWhereUniqueInput | ProgresoEstudianteWhereUniqueInput[]
    update?: ProgresoEstudianteUpdateWithWhereUniqueWithoutModuloInput | ProgresoEstudianteUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: ProgresoEstudianteUpdateManyWithWhereWithoutModuloInput | ProgresoEstudianteUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: ProgresoEstudianteScalarWhereInput | ProgresoEstudianteScalarWhereInput[]
  }

  export type EstudianteCreateNestedOneWithoutProgresoInput = {
    create?: XOR<EstudianteCreateWithoutProgresoInput, EstudianteUncheckedCreateWithoutProgresoInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutProgresoInput
    connect?: EstudianteWhereUniqueInput
  }

  export type ModuloCreateNestedOneWithoutProgresoInput = {
    create?: XOR<ModuloCreateWithoutProgresoInput, ModuloUncheckedCreateWithoutProgresoInput>
    connectOrCreate?: ModuloCreateOrConnectWithoutProgresoInput
    connect?: ModuloWhereUniqueInput
  }

  export type EstudianteUpdateOneRequiredWithoutProgresoNestedInput = {
    create?: XOR<EstudianteCreateWithoutProgresoInput, EstudianteUncheckedCreateWithoutProgresoInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutProgresoInput
    upsert?: EstudianteUpsertWithoutProgresoInput
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutProgresoInput, EstudianteUpdateWithoutProgresoInput>, EstudianteUncheckedUpdateWithoutProgresoInput>
  }

  export type ModuloUpdateOneRequiredWithoutProgresoNestedInput = {
    create?: XOR<ModuloCreateWithoutProgresoInput, ModuloUncheckedCreateWithoutProgresoInput>
    connectOrCreate?: ModuloCreateOrConnectWithoutProgresoInput
    upsert?: ModuloUpsertWithoutProgresoInput
    connect?: ModuloWhereUniqueInput
    update?: XOR<XOR<ModuloUpdateToOneWithWhereWithoutProgresoInput, ModuloUpdateWithoutProgresoInput>, ModuloUncheckedUpdateWithoutProgresoInput>
  }

  export type EstudianteCreateNestedOneWithoutPagosInput = {
    create?: XOR<EstudianteCreateWithoutPagosInput, EstudianteUncheckedCreateWithoutPagosInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutPagosInput
    connect?: EstudianteWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumEstadoPagoTransaccionFieldUpdateOperationsInput = {
    set?: $Enums.EstadoPagoTransaccion
  }

  export type EstudianteUpdateOneRequiredWithoutPagosNestedInput = {
    create?: XOR<EstudianteCreateWithoutPagosInput, EstudianteUncheckedCreateWithoutPagosInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutPagosInput
    upsert?: EstudianteUpsertWithoutPagosInput
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutPagosInput, EstudianteUpdateWithoutPagosInput>, EstudianteUncheckedUpdateWithoutPagosInput>
  }

  export type ProfesorCreateNestedOneWithoutConfiguracionInput = {
    create?: XOR<ProfesorCreateWithoutConfiguracionInput, ProfesorUncheckedCreateWithoutConfiguracionInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutConfiguracionInput
    connect?: ProfesorWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProfesorUpdateOneRequiredWithoutConfiguracionNestedInput = {
    create?: XOR<ProfesorCreateWithoutConfiguracionInput, ProfesorUncheckedCreateWithoutConfiguracionInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutConfiguracionInput
    upsert?: ProfesorUpsertWithoutConfiguracionInput
    connect?: ProfesorWhereUniqueInput
    update?: XOR<XOR<ProfesorUpdateToOneWithWhereWithoutConfiguracionInput, ProfesorUpdateWithoutConfiguracionInput>, ProfesorUncheckedUpdateWithoutConfiguracionInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.UserEstado | EnumUserEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.UserEstado[] | ListEnumUserEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserEstado[] | ListEnumUserEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumUserEstadoFilter<$PrismaModel> | $Enums.UserEstado
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserEstado | EnumUserEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.UserEstado[] | ListEnumUserEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserEstado[] | ListEnumUserEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumUserEstadoWithAggregatesFilter<$PrismaModel> | $Enums.UserEstado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserEstadoFilter<$PrismaModel>
    _max?: NestedEnumUserEstadoFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumEstadoAprobacionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoAprobacion | EnumEstadoAprobacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoAprobacion[] | ListEnumEstadoAprobacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoAprobacion[] | ListEnumEstadoAprobacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoAprobacionFilter<$PrismaModel> | $Enums.EstadoAprobacion
  }

  export type NestedEnumEstadoPagoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPago | EnumEstadoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoFilter<$PrismaModel> | $Enums.EstadoPago
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumEstadoAprobacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoAprobacion | EnumEstadoAprobacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoAprobacion[] | ListEnumEstadoAprobacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoAprobacion[] | ListEnumEstadoAprobacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoAprobacionWithAggregatesFilter<$PrismaModel> | $Enums.EstadoAprobacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoAprobacionFilter<$PrismaModel>
    _max?: NestedEnumEstadoAprobacionFilter<$PrismaModel>
  }

  export type NestedEnumEstadoPagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPago | EnumEstadoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPagoFilter<$PrismaModel>
    _max?: NestedEnumEstadoPagoFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumEstadoSolicitudFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoSolicitud | EnumEstadoSolicitudFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoSolicitud[] | ListEnumEstadoSolicitudFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoSolicitud[] | ListEnumEstadoSolicitudFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoSolicitudFilter<$PrismaModel> | $Enums.EstadoSolicitud
  }

  export type NestedEnumEstadoSolicitudWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoSolicitud | EnumEstadoSolicitudFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoSolicitud[] | ListEnumEstadoSolicitudFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoSolicitud[] | ListEnumEstadoSolicitudFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoSolicitudWithAggregatesFilter<$PrismaModel> | $Enums.EstadoSolicitud
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoSolicitudFilter<$PrismaModel>
    _max?: NestedEnumEstadoSolicitudFilter<$PrismaModel>
  }

  export type NestedEnumEstadoModuloFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoModulo | EnumEstadoModuloFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoModulo[] | ListEnumEstadoModuloFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoModulo[] | ListEnumEstadoModuloFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoModuloFilter<$PrismaModel> | $Enums.EstadoModulo
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumEstadoModuloWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoModulo | EnumEstadoModuloFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoModulo[] | ListEnumEstadoModuloFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoModulo[] | ListEnumEstadoModuloFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoModuloWithAggregatesFilter<$PrismaModel> | $Enums.EstadoModulo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoModuloFilter<$PrismaModel>
    _max?: NestedEnumEstadoModuloFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumEstadoPagoTransaccionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPagoTransaccion | EnumEstadoPagoTransaccionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPagoTransaccion[] | ListEnumEstadoPagoTransaccionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPagoTransaccion[] | ListEnumEstadoPagoTransaccionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoTransaccionFilter<$PrismaModel> | $Enums.EstadoPagoTransaccion
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumEstadoPagoTransaccionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPagoTransaccion | EnumEstadoPagoTransaccionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPagoTransaccion[] | ListEnumEstadoPagoTransaccionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPagoTransaccion[] | ListEnumEstadoPagoTransaccionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoTransaccionWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPagoTransaccion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPagoTransaccionFilter<$PrismaModel>
    _max?: NestedEnumEstadoPagoTransaccionFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EstudianteCreateWithoutUserInput = {
    id?: string
    estadoAprobacion?: $Enums.EstadoAprobacion
    estadoPago?: $Enums.EstadoPago
    fechaAprobacion?: Date | string | null
    fechaPago?: Date | string | null
    montoPagado?: Decimal | DecimalJsLike | number | string | null
    metodoPago?: string | null
    referenciaTransaccion?: string | null
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    fechaInscripcion?: Date | string | null
    progreso?: ProgresoEstudianteCreateNestedManyWithoutEstudianteInput
    pagos?: PagoCreateNestedManyWithoutEstudianteInput
    solicitud?: SolicitudAccesoCreateNestedOneWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutUserInput = {
    id?: string
    estadoAprobacion?: $Enums.EstadoAprobacion
    estadoPago?: $Enums.EstadoPago
    fechaAprobacion?: Date | string | null
    fechaPago?: Date | string | null
    montoPagado?: Decimal | DecimalJsLike | number | string | null
    metodoPago?: string | null
    referenciaTransaccion?: string | null
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    fechaInscripcion?: Date | string | null
    progreso?: ProgresoEstudianteUncheckedCreateNestedManyWithoutEstudianteInput
    pagos?: PagoUncheckedCreateNestedManyWithoutEstudianteInput
    solicitud?: SolicitudAccesoUncheckedCreateNestedOneWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutUserInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutUserInput, EstudianteUncheckedCreateWithoutUserInput>
  }

  export type ProfesorCreateWithoutUserInput = {
    id?: string
    permisos?: ProfesorCreatepermisosInput | string[]
    ultimoLogin?: Date | string | null
    configuracion?: ConfiguracionProfesorCreateNestedOneWithoutProfesorInput
  }

  export type ProfesorUncheckedCreateWithoutUserInput = {
    id?: string
    permisos?: ProfesorCreatepermisosInput | string[]
    ultimoLogin?: Date | string | null
    configuracion?: ConfiguracionProfesorUncheckedCreateNestedOneWithoutProfesorInput
  }

  export type ProfesorCreateOrConnectWithoutUserInput = {
    where: ProfesorWhereUniqueInput
    create: XOR<ProfesorCreateWithoutUserInput, ProfesorUncheckedCreateWithoutUserInput>
  }

  export type EstudianteUpsertWithoutUserInput = {
    update: XOR<EstudianteUpdateWithoutUserInput, EstudianteUncheckedUpdateWithoutUserInput>
    create: XOR<EstudianteCreateWithoutUserInput, EstudianteUncheckedCreateWithoutUserInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutUserInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutUserInput, EstudianteUncheckedUpdateWithoutUserInput>
  }

  export type EstudianteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    estadoAprobacion?: EnumEstadoAprobacionFieldUpdateOperationsInput | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPagado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInscripcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progreso?: ProgresoEstudianteUpdateManyWithoutEstudianteNestedInput
    pagos?: PagoUpdateManyWithoutEstudianteNestedInput
    solicitud?: SolicitudAccesoUpdateOneWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    estadoAprobacion?: EnumEstadoAprobacionFieldUpdateOperationsInput | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPagado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInscripcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progreso?: ProgresoEstudianteUncheckedUpdateManyWithoutEstudianteNestedInput
    pagos?: PagoUncheckedUpdateManyWithoutEstudianteNestedInput
    solicitud?: SolicitudAccesoUncheckedUpdateOneWithoutEstudianteNestedInput
  }

  export type ProfesorUpsertWithoutUserInput = {
    update: XOR<ProfesorUpdateWithoutUserInput, ProfesorUncheckedUpdateWithoutUserInput>
    create: XOR<ProfesorCreateWithoutUserInput, ProfesorUncheckedCreateWithoutUserInput>
    where?: ProfesorWhereInput
  }

  export type ProfesorUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfesorWhereInput
    data: XOR<ProfesorUpdateWithoutUserInput, ProfesorUncheckedUpdateWithoutUserInput>
  }

  export type ProfesorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permisos?: ProfesorUpdatepermisosInput | string[]
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuracion?: ConfiguracionProfesorUpdateOneWithoutProfesorNestedInput
  }

  export type ProfesorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permisos?: ProfesorUpdatepermisosInput | string[]
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    configuracion?: ConfiguracionProfesorUncheckedUpdateOneWithoutProfesorNestedInput
  }

  export type UserCreateWithoutEstudianteInput = {
    id?: string
    email: string
    password?: string | null
    nombre: string
    avatarUrl?: string | null
    rol?: $Enums.UserRole
    estado?: $Enums.UserEstado
    createdAt?: Date | string
    updatedAt?: Date | string
    profesor?: ProfesorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEstudianteInput = {
    id?: string
    email: string
    password?: string | null
    nombre: string
    avatarUrl?: string | null
    rol?: $Enums.UserRole
    estado?: $Enums.UserEstado
    createdAt?: Date | string
    updatedAt?: Date | string
    profesor?: ProfesorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEstudianteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEstudianteInput, UserUncheckedCreateWithoutEstudianteInput>
  }

  export type ProgresoEstudianteCreateWithoutEstudianteInput = {
    id?: string
    completudPorcentaje?: number
    fechaCompletado?: Date | string | null
    ultimaActividad?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modulo: ModuloCreateNestedOneWithoutProgresoInput
  }

  export type ProgresoEstudianteUncheckedCreateWithoutEstudianteInput = {
    id?: string
    moduloId: string
    completudPorcentaje?: number
    fechaCompletado?: Date | string | null
    ultimaActividad?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgresoEstudianteCreateOrConnectWithoutEstudianteInput = {
    where: ProgresoEstudianteWhereUniqueInput
    create: XOR<ProgresoEstudianteCreateWithoutEstudianteInput, ProgresoEstudianteUncheckedCreateWithoutEstudianteInput>
  }

  export type ProgresoEstudianteCreateManyEstudianteInputEnvelope = {
    data: ProgresoEstudianteCreateManyEstudianteInput | ProgresoEstudianteCreateManyEstudianteInput[]
    skipDuplicates?: boolean
  }

  export type PagoCreateWithoutEstudianteInput = {
    id?: string
    monto: Decimal | DecimalJsLike | number | string
    moneda?: string
    proveedor: string
    referenciaExterna: string
    estado?: $Enums.EstadoPagoTransaccion
    fechaPago?: Date | string | null
    createdAt?: Date | string
  }

  export type PagoUncheckedCreateWithoutEstudianteInput = {
    id?: string
    monto: Decimal | DecimalJsLike | number | string
    moneda?: string
    proveedor: string
    referenciaExterna: string
    estado?: $Enums.EstadoPagoTransaccion
    fechaPago?: Date | string | null
    createdAt?: Date | string
  }

  export type PagoCreateOrConnectWithoutEstudianteInput = {
    where: PagoWhereUniqueInput
    create: XOR<PagoCreateWithoutEstudianteInput, PagoUncheckedCreateWithoutEstudianteInput>
  }

  export type PagoCreateManyEstudianteInputEnvelope = {
    data: PagoCreateManyEstudianteInput | PagoCreateManyEstudianteInput[]
    skipDuplicates?: boolean
  }

  export type SolicitudAccesoCreateWithoutEstudianteInput = {
    id?: string
    nombre: string
    email: string
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    estado?: $Enums.EstadoSolicitud
    fechaSolicitud?: Date | string
    fechaRevision?: Date | string | null
    motivoRechazo?: string | null
    createdAt?: Date | string
  }

  export type SolicitudAccesoUncheckedCreateWithoutEstudianteInput = {
    id?: string
    nombre: string
    email: string
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    estado?: $Enums.EstadoSolicitud
    fechaSolicitud?: Date | string
    fechaRevision?: Date | string | null
    motivoRechazo?: string | null
    createdAt?: Date | string
  }

  export type SolicitudAccesoCreateOrConnectWithoutEstudianteInput = {
    where: SolicitudAccesoWhereUniqueInput
    create: XOR<SolicitudAccesoCreateWithoutEstudianteInput, SolicitudAccesoUncheckedCreateWithoutEstudianteInput>
  }

  export type UserUpsertWithoutEstudianteInput = {
    update: XOR<UserUpdateWithoutEstudianteInput, UserUncheckedUpdateWithoutEstudianteInput>
    create: XOR<UserCreateWithoutEstudianteInput, UserUncheckedCreateWithoutEstudianteInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEstudianteInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEstudianteInput, UserUncheckedUpdateWithoutEstudianteInput>
  }

  export type UserUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    estado?: EnumUserEstadoFieldUpdateOperationsInput | $Enums.UserEstado
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profesor?: ProfesorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    estado?: EnumUserEstadoFieldUpdateOperationsInput | $Enums.UserEstado
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profesor?: ProfesorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ProgresoEstudianteUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: ProgresoEstudianteWhereUniqueInput
    update: XOR<ProgresoEstudianteUpdateWithoutEstudianteInput, ProgresoEstudianteUncheckedUpdateWithoutEstudianteInput>
    create: XOR<ProgresoEstudianteCreateWithoutEstudianteInput, ProgresoEstudianteUncheckedCreateWithoutEstudianteInput>
  }

  export type ProgresoEstudianteUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: ProgresoEstudianteWhereUniqueInput
    data: XOR<ProgresoEstudianteUpdateWithoutEstudianteInput, ProgresoEstudianteUncheckedUpdateWithoutEstudianteInput>
  }

  export type ProgresoEstudianteUpdateManyWithWhereWithoutEstudianteInput = {
    where: ProgresoEstudianteScalarWhereInput
    data: XOR<ProgresoEstudianteUpdateManyMutationInput, ProgresoEstudianteUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type ProgresoEstudianteScalarWhereInput = {
    AND?: ProgresoEstudianteScalarWhereInput | ProgresoEstudianteScalarWhereInput[]
    OR?: ProgresoEstudianteScalarWhereInput[]
    NOT?: ProgresoEstudianteScalarWhereInput | ProgresoEstudianteScalarWhereInput[]
    id?: StringFilter<"ProgresoEstudiante"> | string
    estudianteId?: StringFilter<"ProgresoEstudiante"> | string
    moduloId?: StringFilter<"ProgresoEstudiante"> | string
    completudPorcentaje?: IntFilter<"ProgresoEstudiante"> | number
    fechaCompletado?: DateTimeNullableFilter<"ProgresoEstudiante"> | Date | string | null
    ultimaActividad?: DateTimeNullableFilter<"ProgresoEstudiante"> | Date | string | null
    createdAt?: DateTimeFilter<"ProgresoEstudiante"> | Date | string
    updatedAt?: DateTimeFilter<"ProgresoEstudiante"> | Date | string
  }

  export type PagoUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: PagoWhereUniqueInput
    update: XOR<PagoUpdateWithoutEstudianteInput, PagoUncheckedUpdateWithoutEstudianteInput>
    create: XOR<PagoCreateWithoutEstudianteInput, PagoUncheckedCreateWithoutEstudianteInput>
  }

  export type PagoUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: PagoWhereUniqueInput
    data: XOR<PagoUpdateWithoutEstudianteInput, PagoUncheckedUpdateWithoutEstudianteInput>
  }

  export type PagoUpdateManyWithWhereWithoutEstudianteInput = {
    where: PagoScalarWhereInput
    data: XOR<PagoUpdateManyMutationInput, PagoUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type PagoScalarWhereInput = {
    AND?: PagoScalarWhereInput | PagoScalarWhereInput[]
    OR?: PagoScalarWhereInput[]
    NOT?: PagoScalarWhereInput | PagoScalarWhereInput[]
    id?: StringFilter<"Pago"> | string
    estudianteId?: StringFilter<"Pago"> | string
    monto?: DecimalFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"Pago"> | string
    proveedor?: StringFilter<"Pago"> | string
    referenciaExterna?: StringFilter<"Pago"> | string
    estado?: EnumEstadoPagoTransaccionFilter<"Pago"> | $Enums.EstadoPagoTransaccion
    fechaPago?: DateTimeNullableFilter<"Pago"> | Date | string | null
    createdAt?: DateTimeFilter<"Pago"> | Date | string
  }

  export type SolicitudAccesoUpsertWithoutEstudianteInput = {
    update: XOR<SolicitudAccesoUpdateWithoutEstudianteInput, SolicitudAccesoUncheckedUpdateWithoutEstudianteInput>
    create: XOR<SolicitudAccesoCreateWithoutEstudianteInput, SolicitudAccesoUncheckedCreateWithoutEstudianteInput>
    where?: SolicitudAccesoWhereInput
  }

  export type SolicitudAccesoUpdateToOneWithWhereWithoutEstudianteInput = {
    where?: SolicitudAccesoWhereInput
    data: XOR<SolicitudAccesoUpdateWithoutEstudianteInput, SolicitudAccesoUncheckedUpdateWithoutEstudianteInput>
  }

  export type SolicitudAccesoUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoSolicitudFieldUpdateOperationsInput | $Enums.EstadoSolicitud
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolicitudAccesoUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoSolicitudFieldUpdateOperationsInput | $Enums.EstadoSolicitud
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutProfesorInput = {
    id?: string
    email: string
    password?: string | null
    nombre: string
    avatarUrl?: string | null
    rol?: $Enums.UserRole
    estado?: $Enums.UserEstado
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfesorInput = {
    id?: string
    email: string
    password?: string | null
    nombre: string
    avatarUrl?: string | null
    rol?: $Enums.UserRole
    estado?: $Enums.UserEstado
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfesorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfesorInput, UserUncheckedCreateWithoutProfesorInput>
  }

  export type ConfiguracionProfesorCreateWithoutProfesorInput = {
    id?: string
    nombreCurso: string
    descripcionCurso?: string | null
    precioCurso: Decimal | DecimalJsLike | number | string
    moneda?: string
    bioProfesor?: string | null
    fotoProfesorUrl?: string | null
    emailContacto?: string | null
    whatsappNumero?: string | null
    pais?: string | null
    stripeSecretKey?: string | null
    stripePublicKey?: string | null
    stripeWebhookSecret?: string | null
    emailNotificaciones?: string | null
    notificarWhatsApp?: boolean
    notificarEmail?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfiguracionProfesorUncheckedCreateWithoutProfesorInput = {
    id?: string
    nombreCurso: string
    descripcionCurso?: string | null
    precioCurso: Decimal | DecimalJsLike | number | string
    moneda?: string
    bioProfesor?: string | null
    fotoProfesorUrl?: string | null
    emailContacto?: string | null
    whatsappNumero?: string | null
    pais?: string | null
    stripeSecretKey?: string | null
    stripePublicKey?: string | null
    stripeWebhookSecret?: string | null
    emailNotificaciones?: string | null
    notificarWhatsApp?: boolean
    notificarEmail?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfiguracionProfesorCreateOrConnectWithoutProfesorInput = {
    where: ConfiguracionProfesorWhereUniqueInput
    create: XOR<ConfiguracionProfesorCreateWithoutProfesorInput, ConfiguracionProfesorUncheckedCreateWithoutProfesorInput>
  }

  export type UserUpsertWithoutProfesorInput = {
    update: XOR<UserUpdateWithoutProfesorInput, UserUncheckedUpdateWithoutProfesorInput>
    create: XOR<UserCreateWithoutProfesorInput, UserUncheckedCreateWithoutProfesorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfesorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfesorInput, UserUncheckedUpdateWithoutProfesorInput>
  }

  export type UserUpdateWithoutProfesorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    estado?: EnumUserEstadoFieldUpdateOperationsInput | $Enums.UserEstado
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfesorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    estado?: EnumUserEstadoFieldUpdateOperationsInput | $Enums.UserEstado
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ConfiguracionProfesorUpsertWithoutProfesorInput = {
    update: XOR<ConfiguracionProfesorUpdateWithoutProfesorInput, ConfiguracionProfesorUncheckedUpdateWithoutProfesorInput>
    create: XOR<ConfiguracionProfesorCreateWithoutProfesorInput, ConfiguracionProfesorUncheckedCreateWithoutProfesorInput>
    where?: ConfiguracionProfesorWhereInput
  }

  export type ConfiguracionProfesorUpdateToOneWithWhereWithoutProfesorInput = {
    where?: ConfiguracionProfesorWhereInput
    data: XOR<ConfiguracionProfesorUpdateWithoutProfesorInput, ConfiguracionProfesorUncheckedUpdateWithoutProfesorInput>
  }

  export type ConfiguracionProfesorUpdateWithoutProfesorInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreCurso?: StringFieldUpdateOperationsInput | string
    descripcionCurso?: NullableStringFieldUpdateOperationsInput | string | null
    precioCurso?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    bioProfesor?: NullableStringFieldUpdateOperationsInput | string | null
    fotoProfesorUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailContacto?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumero?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripePublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    notificarWhatsApp?: BoolFieldUpdateOperationsInput | boolean
    notificarEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionProfesorUncheckedUpdateWithoutProfesorInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreCurso?: StringFieldUpdateOperationsInput | string
    descripcionCurso?: NullableStringFieldUpdateOperationsInput | string | null
    precioCurso?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    bioProfesor?: NullableStringFieldUpdateOperationsInput | string | null
    fotoProfesorUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailContacto?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumero?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripePublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    notificarWhatsApp?: BoolFieldUpdateOperationsInput | boolean
    notificarEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstudianteCreateWithoutSolicitudInput = {
    id?: string
    estadoAprobacion?: $Enums.EstadoAprobacion
    estadoPago?: $Enums.EstadoPago
    fechaAprobacion?: Date | string | null
    fechaPago?: Date | string | null
    montoPagado?: Decimal | DecimalJsLike | number | string | null
    metodoPago?: string | null
    referenciaTransaccion?: string | null
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    fechaInscripcion?: Date | string | null
    user: UserCreateNestedOneWithoutEstudianteInput
    progreso?: ProgresoEstudianteCreateNestedManyWithoutEstudianteInput
    pagos?: PagoCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutSolicitudInput = {
    id?: string
    userId: string
    estadoAprobacion?: $Enums.EstadoAprobacion
    estadoPago?: $Enums.EstadoPago
    fechaAprobacion?: Date | string | null
    fechaPago?: Date | string | null
    montoPagado?: Decimal | DecimalJsLike | number | string | null
    metodoPago?: string | null
    referenciaTransaccion?: string | null
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    fechaInscripcion?: Date | string | null
    progreso?: ProgresoEstudianteUncheckedCreateNestedManyWithoutEstudianteInput
    pagos?: PagoUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutSolicitudInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutSolicitudInput, EstudianteUncheckedCreateWithoutSolicitudInput>
  }

  export type EstudianteUpsertWithoutSolicitudInput = {
    update: XOR<EstudianteUpdateWithoutSolicitudInput, EstudianteUncheckedUpdateWithoutSolicitudInput>
    create: XOR<EstudianteCreateWithoutSolicitudInput, EstudianteUncheckedCreateWithoutSolicitudInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutSolicitudInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutSolicitudInput, EstudianteUncheckedUpdateWithoutSolicitudInput>
  }

  export type EstudianteUpdateWithoutSolicitudInput = {
    id?: StringFieldUpdateOperationsInput | string
    estadoAprobacion?: EnumEstadoAprobacionFieldUpdateOperationsInput | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPagado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInscripcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutEstudianteNestedInput
    progreso?: ProgresoEstudianteUpdateManyWithoutEstudianteNestedInput
    pagos?: PagoUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutSolicitudInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    estadoAprobacion?: EnumEstadoAprobacionFieldUpdateOperationsInput | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPagado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInscripcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progreso?: ProgresoEstudianteUncheckedUpdateManyWithoutEstudianteNestedInput
    pagos?: PagoUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type ProgresoEstudianteCreateWithoutModuloInput = {
    id?: string
    completudPorcentaje?: number
    fechaCompletado?: Date | string | null
    ultimaActividad?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante: EstudianteCreateNestedOneWithoutProgresoInput
  }

  export type ProgresoEstudianteUncheckedCreateWithoutModuloInput = {
    id?: string
    estudianteId: string
    completudPorcentaje?: number
    fechaCompletado?: Date | string | null
    ultimaActividad?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgresoEstudianteCreateOrConnectWithoutModuloInput = {
    where: ProgresoEstudianteWhereUniqueInput
    create: XOR<ProgresoEstudianteCreateWithoutModuloInput, ProgresoEstudianteUncheckedCreateWithoutModuloInput>
  }

  export type ProgresoEstudianteCreateManyModuloInputEnvelope = {
    data: ProgresoEstudianteCreateManyModuloInput | ProgresoEstudianteCreateManyModuloInput[]
    skipDuplicates?: boolean
  }

  export type ProgresoEstudianteUpsertWithWhereUniqueWithoutModuloInput = {
    where: ProgresoEstudianteWhereUniqueInput
    update: XOR<ProgresoEstudianteUpdateWithoutModuloInput, ProgresoEstudianteUncheckedUpdateWithoutModuloInput>
    create: XOR<ProgresoEstudianteCreateWithoutModuloInput, ProgresoEstudianteUncheckedCreateWithoutModuloInput>
  }

  export type ProgresoEstudianteUpdateWithWhereUniqueWithoutModuloInput = {
    where: ProgresoEstudianteWhereUniqueInput
    data: XOR<ProgresoEstudianteUpdateWithoutModuloInput, ProgresoEstudianteUncheckedUpdateWithoutModuloInput>
  }

  export type ProgresoEstudianteUpdateManyWithWhereWithoutModuloInput = {
    where: ProgresoEstudianteScalarWhereInput
    data: XOR<ProgresoEstudianteUpdateManyMutationInput, ProgresoEstudianteUncheckedUpdateManyWithoutModuloInput>
  }

  export type EstudianteCreateWithoutProgresoInput = {
    id?: string
    estadoAprobacion?: $Enums.EstadoAprobacion
    estadoPago?: $Enums.EstadoPago
    fechaAprobacion?: Date | string | null
    fechaPago?: Date | string | null
    montoPagado?: Decimal | DecimalJsLike | number | string | null
    metodoPago?: string | null
    referenciaTransaccion?: string | null
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    fechaInscripcion?: Date | string | null
    user: UserCreateNestedOneWithoutEstudianteInput
    pagos?: PagoCreateNestedManyWithoutEstudianteInput
    solicitud?: SolicitudAccesoCreateNestedOneWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutProgresoInput = {
    id?: string
    userId: string
    estadoAprobacion?: $Enums.EstadoAprobacion
    estadoPago?: $Enums.EstadoPago
    fechaAprobacion?: Date | string | null
    fechaPago?: Date | string | null
    montoPagado?: Decimal | DecimalJsLike | number | string | null
    metodoPago?: string | null
    referenciaTransaccion?: string | null
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    fechaInscripcion?: Date | string | null
    pagos?: PagoUncheckedCreateNestedManyWithoutEstudianteInput
    solicitud?: SolicitudAccesoUncheckedCreateNestedOneWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutProgresoInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutProgresoInput, EstudianteUncheckedCreateWithoutProgresoInput>
  }

  export type ModuloCreateWithoutProgresoInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    orden?: number
    moduloPrevioId?: string | null
    contenido?: NullableJsonNullValueInput | InputJsonValue
    estado?: $Enums.EstadoModulo
    duracion?: string | null
    objetivos?: ModuloCreateobjetivosInput | string[]
    ejercicio?: NullableJsonNullValueInput | InputJsonValue
    recursos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuloUncheckedCreateWithoutProgresoInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    orden?: number
    moduloPrevioId?: string | null
    contenido?: NullableJsonNullValueInput | InputJsonValue
    estado?: $Enums.EstadoModulo
    duracion?: string | null
    objetivos?: ModuloCreateobjetivosInput | string[]
    ejercicio?: NullableJsonNullValueInput | InputJsonValue
    recursos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuloCreateOrConnectWithoutProgresoInput = {
    where: ModuloWhereUniqueInput
    create: XOR<ModuloCreateWithoutProgresoInput, ModuloUncheckedCreateWithoutProgresoInput>
  }

  export type EstudianteUpsertWithoutProgresoInput = {
    update: XOR<EstudianteUpdateWithoutProgresoInput, EstudianteUncheckedUpdateWithoutProgresoInput>
    create: XOR<EstudianteCreateWithoutProgresoInput, EstudianteUncheckedCreateWithoutProgresoInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutProgresoInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutProgresoInput, EstudianteUncheckedUpdateWithoutProgresoInput>
  }

  export type EstudianteUpdateWithoutProgresoInput = {
    id?: StringFieldUpdateOperationsInput | string
    estadoAprobacion?: EnumEstadoAprobacionFieldUpdateOperationsInput | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPagado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInscripcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutEstudianteNestedInput
    pagos?: PagoUpdateManyWithoutEstudianteNestedInput
    solicitud?: SolicitudAccesoUpdateOneWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutProgresoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    estadoAprobacion?: EnumEstadoAprobacionFieldUpdateOperationsInput | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPagado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInscripcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pagos?: PagoUncheckedUpdateManyWithoutEstudianteNestedInput
    solicitud?: SolicitudAccesoUncheckedUpdateOneWithoutEstudianteNestedInput
  }

  export type ModuloUpsertWithoutProgresoInput = {
    update: XOR<ModuloUpdateWithoutProgresoInput, ModuloUncheckedUpdateWithoutProgresoInput>
    create: XOR<ModuloCreateWithoutProgresoInput, ModuloUncheckedCreateWithoutProgresoInput>
    where?: ModuloWhereInput
  }

  export type ModuloUpdateToOneWithWhereWithoutProgresoInput = {
    where?: ModuloWhereInput
    data: XOR<ModuloUpdateWithoutProgresoInput, ModuloUncheckedUpdateWithoutProgresoInput>
  }

  export type ModuloUpdateWithoutProgresoInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    moduloPrevioId?: NullableStringFieldUpdateOperationsInput | string | null
    contenido?: NullableJsonNullValueInput | InputJsonValue
    estado?: EnumEstadoModuloFieldUpdateOperationsInput | $Enums.EstadoModulo
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    objetivos?: ModuloUpdateobjetivosInput | string[]
    ejercicio?: NullableJsonNullValueInput | InputJsonValue
    recursos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuloUncheckedUpdateWithoutProgresoInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    moduloPrevioId?: NullableStringFieldUpdateOperationsInput | string | null
    contenido?: NullableJsonNullValueInput | InputJsonValue
    estado?: EnumEstadoModuloFieldUpdateOperationsInput | $Enums.EstadoModulo
    duracion?: NullableStringFieldUpdateOperationsInput | string | null
    objetivos?: ModuloUpdateobjetivosInput | string[]
    ejercicio?: NullableJsonNullValueInput | InputJsonValue
    recursos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstudianteCreateWithoutPagosInput = {
    id?: string
    estadoAprobacion?: $Enums.EstadoAprobacion
    estadoPago?: $Enums.EstadoPago
    fechaAprobacion?: Date | string | null
    fechaPago?: Date | string | null
    montoPagado?: Decimal | DecimalJsLike | number | string | null
    metodoPago?: string | null
    referenciaTransaccion?: string | null
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    fechaInscripcion?: Date | string | null
    user: UserCreateNestedOneWithoutEstudianteInput
    progreso?: ProgresoEstudianteCreateNestedManyWithoutEstudianteInput
    solicitud?: SolicitudAccesoCreateNestedOneWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutPagosInput = {
    id?: string
    userId: string
    estadoAprobacion?: $Enums.EstadoAprobacion
    estadoPago?: $Enums.EstadoPago
    fechaAprobacion?: Date | string | null
    fechaPago?: Date | string | null
    montoPagado?: Decimal | DecimalJsLike | number | string | null
    metodoPago?: string | null
    referenciaTransaccion?: string | null
    telefono?: string | null
    pais?: string | null
    experiencia?: string | null
    interes?: string | null
    fechaInscripcion?: Date | string | null
    progreso?: ProgresoEstudianteUncheckedCreateNestedManyWithoutEstudianteInput
    solicitud?: SolicitudAccesoUncheckedCreateNestedOneWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutPagosInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutPagosInput, EstudianteUncheckedCreateWithoutPagosInput>
  }

  export type EstudianteUpsertWithoutPagosInput = {
    update: XOR<EstudianteUpdateWithoutPagosInput, EstudianteUncheckedUpdateWithoutPagosInput>
    create: XOR<EstudianteCreateWithoutPagosInput, EstudianteUncheckedCreateWithoutPagosInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutPagosInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutPagosInput, EstudianteUncheckedUpdateWithoutPagosInput>
  }

  export type EstudianteUpdateWithoutPagosInput = {
    id?: StringFieldUpdateOperationsInput | string
    estadoAprobacion?: EnumEstadoAprobacionFieldUpdateOperationsInput | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPagado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInscripcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutEstudianteNestedInput
    progreso?: ProgresoEstudianteUpdateManyWithoutEstudianteNestedInput
    solicitud?: SolicitudAccesoUpdateOneWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutPagosInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    estadoAprobacion?: EnumEstadoAprobacionFieldUpdateOperationsInput | $Enums.EstadoAprobacion
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPagado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    interes?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInscripcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progreso?: ProgresoEstudianteUncheckedUpdateManyWithoutEstudianteNestedInput
    solicitud?: SolicitudAccesoUncheckedUpdateOneWithoutEstudianteNestedInput
  }

  export type ProfesorCreateWithoutConfiguracionInput = {
    id?: string
    permisos?: ProfesorCreatepermisosInput | string[]
    ultimoLogin?: Date | string | null
    user: UserCreateNestedOneWithoutProfesorInput
  }

  export type ProfesorUncheckedCreateWithoutConfiguracionInput = {
    id?: string
    userId: string
    permisos?: ProfesorCreatepermisosInput | string[]
    ultimoLogin?: Date | string | null
  }

  export type ProfesorCreateOrConnectWithoutConfiguracionInput = {
    where: ProfesorWhereUniqueInput
    create: XOR<ProfesorCreateWithoutConfiguracionInput, ProfesorUncheckedCreateWithoutConfiguracionInput>
  }

  export type ProfesorUpsertWithoutConfiguracionInput = {
    update: XOR<ProfesorUpdateWithoutConfiguracionInput, ProfesorUncheckedUpdateWithoutConfiguracionInput>
    create: XOR<ProfesorCreateWithoutConfiguracionInput, ProfesorUncheckedCreateWithoutConfiguracionInput>
    where?: ProfesorWhereInput
  }

  export type ProfesorUpdateToOneWithWhereWithoutConfiguracionInput = {
    where?: ProfesorWhereInput
    data: XOR<ProfesorUpdateWithoutConfiguracionInput, ProfesorUncheckedUpdateWithoutConfiguracionInput>
  }

  export type ProfesorUpdateWithoutConfiguracionInput = {
    id?: StringFieldUpdateOperationsInput | string
    permisos?: ProfesorUpdatepermisosInput | string[]
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProfesorNestedInput
  }

  export type ProfesorUncheckedUpdateWithoutConfiguracionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permisos?: ProfesorUpdatepermisosInput | string[]
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProgresoEstudianteCreateManyEstudianteInput = {
    id?: string
    moduloId: string
    completudPorcentaje?: number
    fechaCompletado?: Date | string | null
    ultimaActividad?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoCreateManyEstudianteInput = {
    id?: string
    monto: Decimal | DecimalJsLike | number | string
    moneda?: string
    proveedor: string
    referenciaExterna: string
    estado?: $Enums.EstadoPagoTransaccion
    fechaPago?: Date | string | null
    createdAt?: Date | string
  }

  export type ProgresoEstudianteUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    completudPorcentaje?: IntFieldUpdateOperationsInput | number
    fechaCompletado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimaActividad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modulo?: ModuloUpdateOneRequiredWithoutProgresoNestedInput
  }

  export type ProgresoEstudianteUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    completudPorcentaje?: IntFieldUpdateOperationsInput | number
    fechaCompletado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimaActividad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgresoEstudianteUncheckedUpdateManyWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduloId?: StringFieldUpdateOperationsInput | string
    completudPorcentaje?: IntFieldUpdateOperationsInput | number
    fechaCompletado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimaActividad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    referenciaExterna?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoPagoTransaccionFieldUpdateOperationsInput | $Enums.EstadoPagoTransaccion
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    referenciaExterna?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoPagoTransaccionFieldUpdateOperationsInput | $Enums.EstadoPagoTransaccion
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoUncheckedUpdateManyWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    referenciaExterna?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoPagoTransaccionFieldUpdateOperationsInput | $Enums.EstadoPagoTransaccion
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgresoEstudianteCreateManyModuloInput = {
    id?: string
    estudianteId: string
    completudPorcentaje?: number
    fechaCompletado?: Date | string | null
    ultimaActividad?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgresoEstudianteUpdateWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    completudPorcentaje?: IntFieldUpdateOperationsInput | number
    fechaCompletado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimaActividad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneRequiredWithoutProgresoNestedInput
  }

  export type ProgresoEstudianteUncheckedUpdateWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    completudPorcentaje?: IntFieldUpdateOperationsInput | number
    fechaCompletado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimaActividad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgresoEstudianteUncheckedUpdateManyWithoutModuloInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    completudPorcentaje?: IntFieldUpdateOperationsInput | number
    fechaCompletado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimaActividad?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use EstudianteCountOutputTypeDefaultArgs instead
     */
    export type EstudianteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstudianteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuloCountOutputTypeDefaultArgs instead
     */
    export type ModuloCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuloCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstudianteDefaultArgs instead
     */
    export type EstudianteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstudianteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfesorDefaultArgs instead
     */
    export type ProfesorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfesorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SolicitudAccesoDefaultArgs instead
     */
    export type SolicitudAccesoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SolicitudAccesoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuloDefaultArgs instead
     */
    export type ModuloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuloDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgresoEstudianteDefaultArgs instead
     */
    export type ProgresoEstudianteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgresoEstudianteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PagoDefaultArgs instead
     */
    export type PagoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PagoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfiguracionProfesorDefaultArgs instead
     */
    export type ConfiguracionProfesorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConfiguracionProfesorDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}